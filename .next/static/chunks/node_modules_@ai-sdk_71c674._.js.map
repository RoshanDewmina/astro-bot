{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/nanoid/non-secure/index.js"],"sourcesContent":["let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nexport { nanoid, customAlphabet }\n"],"names":[],"mappings":";;;;AAAA,IAAI,cACF;AACF,IAAI,iBAAiB,CAAC,UAAU,cAAc,EAAE;IAC9C,OAAO,CAAC,OAAO,WAAW;QACxB,IAAI,KAAK;QACT,IAAI,IAAI;QACR,MAAO,IAAK;YACV,MAAM,QAAQ,CAAC,AAAC,KAAK,MAAM,KAAK,SAAS,MAAM,GAAI,EAAE;QACvD;QACA,OAAO;IACT;AACF;AACA,IAAI,SAAS,CAAC,OAAO,EAAE;IACrB,IAAI,KAAK;IACT,IAAI,IAAI;IACR,MAAO,IAAK;QACV,MAAM,WAAW,CAAC,AAAC,KAAK,MAAM,KAAK,KAAM,EAAE;IAC7C;IACA,OAAO;AACT"}},
    {"offset": {"line": 29, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/node_modules/nanoid/non-secure/index.js"],"sourcesContent":["let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nexport { nanoid, customAlphabet }\n"],"names":[],"mappings":";;;;AAAA,IAAI,cACF;AACF,IAAI,iBAAiB,CAAC,UAAU,cAAc,EAAE;IAC9C,OAAO,CAAC,OAAO,WAAW;QACxB,IAAI,KAAK;QACT,IAAI,IAAI;QACR,MAAO,IAAK;YACV,MAAM,QAAQ,CAAC,AAAC,KAAK,MAAM,KAAK,SAAS,MAAM,GAAI,EAAE;QACvD;QACA,OAAO;IACT;AACF;AACA,IAAI,SAAS,CAAC,OAAO,EAAE;IACrB,IAAI,KAAK;IACT,IAAI,IAAI;IACR,MAAO,IAAK;QACV,MAAM,WAAW,CAAC,AAAC,KAAK,MAAM,KAAK,KAAM,EAAE;IAC7C;IACA,OAAO;AACT"}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/errors/api-call-error.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/errors/empty-response-body-error.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/errors/get-error-message.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/errors/invalid-prompt-error.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/errors/invalid-response-data-error.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/errors/load-api-key-error.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/errors/load-setting-error.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/errors/no-content-generated-error.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/errors/no-such-model-error.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/errors/too-many-embedding-values-for-call-error.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/errors/unsupported-functionality-error.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/node_modules/@ai-sdk/provider/src/json-value/is-json.ts"],"sourcesContent":["/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n\n  /**\n   * Returns a JSON representation of the error.\n   * @returns {Object} An object containing the error's name, message, and cause.\n   *\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_APICallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class APICallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n\n  readonly responseHeaders?: Record<string, string>;\n  readonly responseBody?: string;\n\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 408 || // request timeout\n        statusCode === 409 || // conflict\n        statusCode === 429 || // too many requests\n        statusCode >= 500), // server error\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseHeaders?: Record<string, string>;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is APICallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isAPICallError(error: unknown): error is APICallError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as APICallError).url === 'string' &&\n      typeof (error as APICallError).requestBodyValues === 'object' &&\n      ((error as APICallError).statusCode == null ||\n        typeof (error as APICallError).statusCode === 'number') &&\n      ((error as APICallError).responseHeaders == null ||\n        typeof (error as APICallError).responseHeaders === 'object') &&\n      ((error as APICallError).responseBody == null ||\n        typeof (error as APICallError).responseBody === 'string') &&\n      ((error as APICallError).cause == null ||\n        typeof (error as APICallError).cause === 'object') &&\n      typeof (error as APICallError).isRetryable === 'boolean' &&\n      ((error as APICallError).data == null ||\n        typeof (error as APICallError).data === 'object')\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      requestBodyValues: this.requestBodyValues,\n      statusCode: this.statusCode,\n      responseHeaders: this.responseHeaders,\n      responseBody: this.responseBody,\n      cause: this.cause,\n      isRetryable: this.isRetryable,\n      data: this.data,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_EmptyResponseBodyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class EmptyResponseBodyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'Empty response body' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is EmptyResponseBodyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isEmptyResponseBodyError(\n    error: unknown,\n  ): error is EmptyResponseBodyError {\n    return error instanceof Error && error.name === name;\n  }\n}\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidPromptError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A prompt is invalid. This error should be thrown by providers when they cannot\n * process a prompt.\n */\nexport class InvalidPromptError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly prompt: unknown;\n\n  constructor({\n    prompt,\n    message,\n    cause,\n  }: {\n    prompt: unknown;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message: `Invalid prompt: ${message}`, cause });\n\n    this.prompt = prompt;\n  }\n\n  static isInstance(error: unknown): error is InvalidPromptError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidPromptError(error: unknown): error is InvalidPromptError {\n    return error instanceof Error && error.name === name && prompt != null;\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      prompt: this.prompt,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidResponseDataError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Server returned a response with invalid data content.\n * This should be thrown by providers when they cannot parse the response from the API.\n */\nexport class InvalidResponseDataError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly data: unknown;\n\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`,\n  }: {\n    data: unknown;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is InvalidResponseDataError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidResponseDataError(\n    error: unknown,\n  ): error is InvalidResponseDataError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      (error as InvalidResponseDataError).data != null\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      data: this.data,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isJSONParseError(error: unknown): error is JSONParseError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      'text' in error &&\n      typeof error.text === 'string'\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n\n      valueText: this.text,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadAPIKeyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadAPIKeyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadAPIKeyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadAPIKeyError(error: unknown): error is LoadAPIKeyError {\n    return error instanceof Error && error.name === name;\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadSettingError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadSettingError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadSettingError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadSettingError(error: unknown): error is LoadSettingError {\n    return error instanceof Error && error.name === name;\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoContentGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when the AI provider fails to generate any content.\n */\nexport class NoContentGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({\n    message = 'No content generated.',\n  }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoContentGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isNoContentGeneratedError(\n    error: unknown,\n  ): error is NoContentGeneratedError {\n    return error instanceof Error && error.name === name;\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      cause: this.cause,\n      message: this.message,\n      stack: this.stack,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoSuchModelError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchModelError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly modelId: string;\n  readonly modelType: 'languageModel' | 'textEmbeddingModel';\n\n  constructor({\n    errorName = name,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`,\n  }: {\n    errorName?: string;\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel';\n    message?: string;\n  }) {\n    super({ name: errorName, message });\n\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n\n  static isInstance(error: unknown): error is NoSuchModelError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchModelError(error: unknown): error is NoSuchModelError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as NoSuchModelError).modelId === 'string' &&\n      typeof (error as NoSuchModelError).modelType === 'string'\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      modelId: this.modelId,\n      modelType: this.modelType,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_TooManyEmbeddingValuesForCallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TooManyEmbeddingValuesForCallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly provider: string;\n  readonly modelId: string;\n  readonly maxEmbeddingsPerCall: number;\n  readonly values: Array<unknown>;\n\n  constructor(options: {\n    provider: string;\n    modelId: string;\n    maxEmbeddingsPerCall: number;\n    values: Array<unknown>;\n  }) {\n    super({\n      name,\n      message:\n        `Too many values for a single embedding call. ` +\n        `The ${options.provider} model \"${options.modelId}\" can only embed up to ` +\n        `${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`,\n    });\n\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n\n  static isInstance(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTooManyEmbeddingValuesForCallError(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      'provider' in error &&\n      typeof error.provider === 'string' &&\n      'modelId' in error &&\n      typeof error.modelId === 'string' &&\n      'maxEmbeddingsPerCall' in error &&\n      typeof error.maxEmbeddingsPerCall === 'number' &&\n      'values' in error &&\n      Array.isArray(error.values)\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      provider: this.provider,\n      modelId: this.modelId,\n      maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n      values: this.values,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTypeValidationError(error: unknown): error is TypeValidationError {\n    return error instanceof Error && error.name === name;\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n\n      value: this.value,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_UnsupportedFunctionalityError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class UnsupportedFunctionalityError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly functionality: string;\n\n  constructor({ functionality }: { functionality: string }) {\n    super({\n      name,\n      message: `'${functionality}' functionality not supported.`,\n    });\n\n    this.functionality = functionality;\n  }\n\n  static isInstance(error: unknown): error is UnsupportedFunctionalityError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isUnsupportedFunctionalityError(\n    error: unknown,\n  ): error is UnsupportedFunctionalityError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as UnsupportedFunctionalityError).functionality === 'string'\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      functionality: this.functionality,\n    };\n  }\n}\n","import { JSONArray, JSONObject, JSONValue } from './json-value';\n\nexport function isJSONValue(value: unknown): value is JSONValue {\n  if (\n    value === null ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  ) {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n\n  if (typeof value === 'object') {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    );\n  }\n\n  return false;\n}\n\nexport function isJSONArray(value: unknown): value is JSONArray {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\n\nexport function isJSONObject(value: unknown): value is JSONObject {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    )\n  );\n}\n"],"names":["name","marker","symbol","_a","prompt"],"mappings":";;;;;;;;;;;;;;;;;;;;AAIA,IAAM,SAAS;AACf,IAAM,SAAS,OAAO,GAAA,CAAI;AAL1B,IAAA;AAWO,IAAM,cAAN,MAAM,oBAAmB;IAAM;;;;;;;GAAA,GAgBpC,YAAY,EACV,MAAAA,MAAAA,EACA,OAAA,EACA,KAAA,EACF,CAIG;QACD,KAAA,CAAM;QAxBR,IAAA,CAAkB,GAAA,GAAU;QA0B1B,IAAA,CAAK,IAAA,GAAOA;QACZ,IAAA,CAAK,KAAA,GAAQ;IACf;IAAA;;;;GAAA,GAOA,OAAO,WAAW,KAAA,EAAqC;QACrD,OAAO,YAAW,SAAA,CAAU,OAAO;IACrC;IAEA,OAAiB,UAAU,KAAA,EAAgBC,QAAAA,EAAyB;QAClE,MAAM,eAAe,OAAO,GAAA,CAAIA;QAChC,OACE,SAAS,QACT,OAAO,UAAU,YACjB,gBAAgB,SAChB,OAAO,KAAA,CAAM,aAAY,KAAM,aAC/B,KAAA,CAAM,aAAY,KAAM;IAE5B;IAAA;;;;;GAAA,GAQA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;QAChB;IACF;AACF;AA9DoB,KAAA;AADb,IAAM,aAAN;;ACTP,IAAM,OAAO;AACb,IAAMA,UAAS,CAAA,gBAAA,EAAmB,KAAI,CAAA;AACtC,IAAMC,UAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAE;AAMO,IAAM,eAAN,cAA2B;IAahC,YAAY,EACV,OAAA,EACA,GAAA,EACA,iBAAA,EACA,UAAA,EACA,eAAA,EACA,YAAA,EACA,KAAA,EACA,cAAc,cAAc,QAAA,CACzB,eAAe,OAAA,kBAAA;IACd,eAAe,OAAA,WAAA;IACf,eAAe,OAAA,oBAAA;IACf,cAAc,GAAA,CAAA,EAAA,eAAA;IAClB,IAAA,EACF,CAUG;QACD,KAAA,CAAM;YAAE;YAAM;YAAS;QAAM;QArC/B,IAAA,CAAkBA,IAAAA,GAAU;QAuC1B,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,iBAAA,GAAoB;QACzB,IAAA,CAAK,UAAA,GAAa;QAClB,IAAA,CAAK,eAAA,GAAkB;QACvB,IAAA,CAAK,YAAA,GAAe;QACpB,IAAA,CAAK,WAAA,GAAc;QACnB,IAAA,CAAK,IAAA,GAAO;IACd;IAEA,OAAO,WAAW,KAAA,EAAuC;QACvD,OAAO,WAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,eAAe,KAAA,EAAuC;QAC3D,OACE,iBAAiB,SACjB,MAAM,IAAA,KAAS,QACf,OAAQ,MAAuB,GAAA,KAAQ,YACvC,OAAQ,MAAuB,iBAAA,KAAsB,YAAA,CACnD,MAAuB,UAAA,IAAc,QACrC,OAAQ,MAAuB,UAAA,KAAe,QAAA,KAAA,CAC9C,MAAuB,eAAA,IAAmB,QAC1C,OAAQ,MAAuB,eAAA,KAAoB,QAAA,KAAA,CACnD,MAAuB,YAAA,IAAgB,QACvC,OAAQ,MAAuB,YAAA,KAAiB,QAAA,KAAA,CAChD,MAAuB,KAAA,IAAS,QAChC,OAAQ,MAAuB,KAAA,KAAU,QAAA,KAC3C,OAAQ,MAAuB,WAAA,KAAgB,aAAA,CAC7C,MAAuB,IAAA,IAAQ,QAC/B,OAAQ,MAAuB,IAAA,KAAS,QAAA;IAE9C;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,KAAK,IAAA,CAAK,GAAA;YACV,mBAAmB,IAAA,CAAK,iBAAA;YACxB,YAAY,IAAA,CAAK,UAAA;YACjB,iBAAiB,IAAA,CAAK,eAAA;YACtB,cAAc,IAAA,CAAK,YAAA;YACnB,OAAO,IAAA,CAAK,KAAA;YACZ,aAAa,IAAA,CAAK,WAAA;YAClB,MAAM,IAAA,CAAK,IAAA;QACb;IACF;AACF;AA5FoBE,MAAAD;;ACLpB,IAAMF,QAAO;AACb,IAAMC,UAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA;AACtC,IAAME,UAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAE;AAMO,IAAM,yBAAN,cAAqC;IAAW,qBAAA;IAGrD,YAAY,EAAE,UAAU,qBAAA,EAAsB,GAA0B,CAAC,CAAA,CAAG;QAC1E,KAAA,CAAM;YAAE,MAAAH;YAAM;QAAQ;QAHxB,IAAA,CAAkBG,IAAAA,GAAU;IAI5B;IAEA,OAAO,WAAW,KAAA,EAAiD;QACjE,OAAO,WAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,yBACL,KAAA,EACiC;QACjC,OAAO,iBAAiB,SAAS,MAAM,IAAA,KAASD;IAClD;AACF;AAlBoBG,MAAAD;;ACPb,SAAS,gBAAgB,KAAA;IAC9B,IAAI,SAAS,MAAM;QACjB,OAAO;IACT;IAEA,IAAI,OAAO,UAAU,UAAU;QAC7B,OAAO;IACT;IAEA,IAAI,iBAAiB,OAAO;QAC1B,OAAO,MAAM,OAAA;IACf;IAEA,OAAO,KAAK,SAAA,CAAU;AACxB;;ACZA,IAAMF,QAAO;AACb,IAAMC,UAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA;AACtC,IAAME,UAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAE;AAUO,IAAM,qBAAN,cAAiC;IAKtC,YAAY,EACV,QAAAC,OAAAA,EACA,OAAA,EACA,KAAA,EACF,CAIG;QACD,KAAA,CAAM;YAAE,MAAAJ;YAAM,SAAS,CAAA,gBAAA,EAAmB,QAAO,CAAA;YAAI;QAAM;QAb7D,IAAA,CAAkBG,IAAAA,GAAU;QAe1B,IAAA,CAAK,MAAA,GAASC;IAChB;IAEA,OAAO,WAAW,KAAA,EAA6C;QAC7D,OAAO,WAAW,SAAA,CAAU,OAAOH;IACrC;IAAA;;GAAA,GAKA,OAAO,qBAAqB,KAAA,EAA6C;QACvE,OAAO,iBAAiB,SAAS,MAAM,IAAA,KAASD,SAAQ,UAAU;IACpE;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,OAAO,IAAA,CAAK,KAAA;YAEZ,QAAQ,IAAA,CAAK,MAAA;QACf;IACF;AACF;AAzCoBG,MAAAD;;ACTpB,IAAMF,QAAO;AACb,IAAMC,UAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA;AACtC,IAAME,UAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAE;AAUO,IAAM,2BAAN,cAAuC;IAK5C,YAAY,EACV,IAAA,EACA,UAAU,CAAA,uBAAA,EAA0B,KAAK,SAAA,CAAU,MAAK,CAAA,CAAA,EAC1D,CAGG;QACD,KAAA,CAAM;YAAE,MAAAH;YAAM;QAAQ;QAXxB,IAAA,CAAkBG,IAAAA,GAAU;QAa1B,IAAA,CAAK,IAAA,GAAO;IACd;IAEA,OAAO,WAAW,KAAA,EAAmD;QACnE,OAAO,WAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,2BACL,KAAA,EACmC;QACnC,OACE,iBAAiB,SACjB,MAAM,IAAA,KAASD,SACd,MAAmC,IAAA,IAAQ;IAEhD;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,OAAO,IAAA,CAAK,KAAA;YAEZ,MAAM,IAAA,CAAK,IAAA;QACb;IACF;AACF;AA7CoBG,MAAAD;;ACRpB,IAAMF,QAAO;AACb,IAAMC,UAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA;AACtC,IAAME,UAAS,OAAO,GAAA,CAAID;AAL1B,IAAAE;AAOO,IAAM,iBAAN,cAA6B;IAKlC,YAAY,EAAE,IAAA,EAAM,KAAA,EAAM,CAAqC;QAC7D,KAAA,CAAM;YACJ,MAAAH;YACA,SACE,CAAA,2BAAA,EACS,KAAI;eAAA,EACK,gBAAgB,OAAM,CAAA;YAC1C;QACF;QAZF,IAAA,CAAkBG,IAAAA,GAAU;QAc1B,IAAA,CAAK,IAAA,GAAO;IACd;IAEA,OAAO,WAAW,KAAA,EAAyC;QACzD,OAAO,WAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,iBAAiB,KAAA,EAAyC;QAC/D,OACE,iBAAiB,SACjB,MAAM,IAAA,KAASD,SACf,UAAU,SACV,OAAO,MAAM,IAAA,KAAS;IAE1B;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,OAAO,IAAA,CAAK,KAAA;YACZ,OAAO,IAAA,CAAK,KAAA;YAEZ,WAAW,IAAA,CAAK,IAAA;QAClB;IACF;AACF;AA9CoBG,MAAAD;;ACNpB,IAAMF,QAAO;AACb,IAAMC,UAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA;AACtC,IAAME,UAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAE;AAMO,IAAM,kBAAN,cAA8B;IAAW,qBAAA;IAG9C,YAAY,EAAE,OAAA,EAAQ,CAAwB;QAC5C,KAAA,CAAM;YAAE,MAAAH;YAAM;QAAQ;QAHxB,IAAA,CAAkBG,IAAAA,GAAU;IAI5B;IAEA,OAAO,WAAW,KAAA,EAA0C;QAC1D,OAAO,WAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,kBAAkB,KAAA,EAA0C;QACjE,OAAO,iBAAiB,SAAS,MAAM,IAAA,KAASD;IAClD;AACF;AAhBoBG,MAAAD;;ACLpB,IAAMF,QAAO;AACb,IAAMC,UAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA;AACtC,IAAME,UAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAE;AAMO,IAAM,mBAAN,cAA+B;IAAW,qBAAA;IAG/C,YAAY,EAAE,OAAA,EAAQ,CAAwB;QAC5C,KAAA,CAAM;YAAE,MAAAH;YAAM;QAAQ;QAHxB,IAAA,CAAkBG,IAAAA,GAAU;IAI5B;IAEA,OAAO,WAAW,KAAA,EAA2C;QAC3D,OAAO,WAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,mBAAmB,KAAA,EAA2C;QACnE,OAAO,iBAAiB,SAAS,MAAM,IAAA,KAASD;IAClD;AACF;AAhBoBG,MAAAD;;ACLpB,IAAMF,QAAO;AACb,IAAMC,UAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA;AACtC,IAAME,UAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAE;AASO,IAAM,0BAAN,cAAsC;IAAW,qBAAA;IAGtD,YAAY,EACV,UAAU,uBAAA,EACZ,GAA0B,CAAC,CAAA,CAAG;QAC5B,KAAA,CAAM;YAAE,MAAAH;YAAM;QAAQ;QALxB,IAAA,CAAkBG,IAAAA,GAAU;IAM5B;IAEA,OAAO,WAAW,KAAA,EAAkD;QAClE,OAAO,WAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,0BACL,KAAA,EACkC;QAClC,OAAO,iBAAiB,SAAS,MAAM,IAAA,KAASD;IAClD;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,OAAO,IAAA,CAAK,KAAA;YACZ,SAAS,IAAA,CAAK,OAAA;YACd,OAAO,IAAA,CAAK,KAAA;QACd;IACF;AACF;AAhCoBG,MAAAD;;ACRpB,IAAMF,QAAO;AACb,IAAMC,WAAS,CAAA,gBAAA,EAAmBD,MAAI,CAAA;AACtC,IAAME,WAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAE;AAMO,IAAM,mBAAN,cAA+B;IAMpC,YAAY,EACV,YAAYH,KAAAA,EACZ,OAAA,EACA,SAAA,EACA,UAAU,CAAA,QAAA,EAAW,UAAS,EAAA,EAAK,QAAO,CAAA,EAC5C,CAKG;QACD,KAAA,CAAM;YAAE,MAAM;YAAW;QAAQ;QAhBnC,IAAA,CAAkBG,KAAAA,GAAU;QAkB1B,IAAA,CAAK,OAAA,GAAU;QACf,IAAA,CAAK,SAAA,GAAY;IACnB;IAEA,OAAO,WAAW,KAAA,EAA2C;QAC3D,OAAO,WAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,mBAAmB,KAAA,EAA2C;QACnE,OACE,iBAAiB,SACjB,MAAM,IAAA,KAASD,SACf,OAAQ,MAA2B,OAAA,KAAY,YAC/C,OAAQ,MAA2B,SAAA,KAAc;IAErD;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,OAAO,IAAA,CAAK,KAAA;YAEZ,SAAS,IAAA,CAAK,OAAA;YACd,WAAW,IAAA,CAAK,SAAA;QAClB;IACF;AACF;AAnDoBG,OAAAD;;ACLpB,IAAMF,SAAO;AACb,IAAMC,WAAS,CAAA,gBAAA,EAAmBD,OAAI,CAAA;AACtC,IAAME,WAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAE;AAMO,IAAM,qCAAN,cAAiD;IAQtD,YAAY,OAAA,CAKT;QACD,KAAA,CAAM;YACJ,MAAAH;YACA,SACE,CAAA,iDAAA,EACO,QAAQ,QAAQ,CAAA,QAAA,EAAW,QAAQ,OAAO,CAAA,uBAAA,EAC9C,QAAQ,oBAAoB,CAAA,sBAAA,EAAyB,QAAQ,MAAA,CAAO,MAAM,CAAA,sBAAA,CAAA;QACjF;QAnBF,IAAA,CAAkBG,KAAAA,GAAU;QAqB1B,IAAA,CAAK,QAAA,GAAW,QAAQ,QAAA;QACxB,IAAA,CAAK,OAAA,GAAU,QAAQ,OAAA;QACvB,IAAA,CAAK,oBAAA,GAAuB,QAAQ,oBAAA;QACpC,IAAA,CAAK,MAAA,GAAS,QAAQ,MAAA;IACxB;IAEA,OAAO,WACL,KAAA,EAC6C;QAC7C,OAAO,WAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,qCACL,KAAA,EAC6C;QAC7C,OACE,iBAAiB,SACjB,MAAM,IAAA,KAASD,UACf,cAAc,SACd,OAAO,MAAM,QAAA,KAAa,YAC1B,aAAa,SACb,OAAO,MAAM,OAAA,KAAY,YACzB,0BAA0B,SAC1B,OAAO,MAAM,oBAAA,KAAyB,YACtC,YAAY,SACZ,MAAM,OAAA,CAAQ,MAAM,MAAM;IAE9B;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,OAAO,IAAA,CAAK,KAAA;YAEZ,UAAU,IAAA,CAAK,QAAA;YACf,SAAS,IAAA,CAAK,OAAA;YACd,sBAAsB,IAAA,CAAK,oBAAA;YAC3B,QAAQ,IAAA,CAAK,MAAA;QACf;IACF;AACF;AApEoBG,OAAAD;;ACJpB,IAAMF,SAAO;AACb,IAAMC,WAAS,CAAA,gBAAA,EAAmBD,OAAI,CAAA;AACtC,IAAME,WAAS,OAAO,GAAA,CAAID;AAL1B,IAAAE;AAOO,IAAM,uBAAN,MAAM,6BAA4B;IAKvC,YAAY,EAAE,KAAA,EAAO,KAAA,EAAM,CAAuC;QAChE,KAAA,CAAM;YACJ,MAAAH;YACA,SACE,CAAA,+BAAA,EACU,KAAK,SAAA,CAAU,OAAM;eAAA,EACb,gBAAgB,OAAM,CAAA;YAC1C;QACF;QAZF,IAAA,CAAkBG,KAAAA,GAAU;QAc1B,IAAA,CAAK,KAAA,GAAQ;IACf;IAEA,OAAO,WAAW,KAAA,EAA8C;QAC9D,OAAO,WAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;;;;;;;;GAAA,GAYA,OAAO,KAAK,EACV,KAAA,EACA,KAAA,EACF,EAGwB;QACtB,OAAO,qBAAoB,UAAA,CAAW,UAAU,MAAM,KAAA,KAAU,QAC5D,QACA,IAAI,qBAAoB;YAAE;YAAO;QAAM;IAC7C;IAAA;;GAAA,GAKA,OAAO,sBAAsB,KAAA,EAA8C;QACzE,OAAO,iBAAiB,SAAS,MAAM,IAAA,KAASD;IAClD;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,OAAO,IAAA,CAAK,KAAA;YACZ,OAAO,IAAA,CAAK,KAAA;YAEZ,OAAO,IAAA,CAAK,KAAA;QACd;IACF;AACF;AA/DoBG,OAAAD;AADb,IAAM,sBAAN;;ACLP,IAAMF,SAAO;AACb,IAAMC,WAAS,CAAA,gBAAA,EAAmBD,OAAI,CAAA;AACtC,IAAME,WAAS,OAAO,GAAA,CAAID;AAJ1B,IAAAE;AAMO,IAAM,gCAAN,cAA4C;IAKjD,YAAY,EAAE,aAAA,EAAc,CAA8B;QACxD,KAAA,CAAM;YACJ,MAAAH;YACA,SAAS,CAAA,CAAA,EAAI,cAAa,8BAAA,CAAA;QAC5B;QARF,IAAA,CAAkBG,KAAAA,GAAU;QAU1B,IAAA,CAAK,aAAA,GAAgB;IACvB;IAEA,OAAO,WAAW,KAAA,EAAwD;QACxE,OAAO,WAAW,SAAA,CAAU,OAAOF;IACrC;IAAA;;GAAA,GAKA,OAAO,gCACL,KAAA,EACwC;QACxC,OACE,iBAAiB,SACjB,MAAM,IAAA,KAASD,UACf,OAAQ,MAAwC,aAAA,KAAkB;IAEtE;IAAA;;GAAA,GAKA,SAAS;QACP,OAAO;YACL,MAAM,IAAA,CAAK,IAAA;YACX,SAAS,IAAA,CAAK,OAAA;YACd,OAAO,IAAA,CAAK,KAAA;YAEZ,eAAe,IAAA,CAAK,aAAA;QACtB;IACF;AACF;AA1CoBG,OAAAD;;ACLb,SAAS,YAAY,KAAA;IAC1B,IACE,UAAU,QACV,OAAO,UAAU,YACjB,OAAO,UAAU,YACjB,OAAO,UAAU,WACjB;QACA,OAAO;IACT;IAEA,IAAI,MAAM,OAAA,CAAQ,QAAQ;QACxB,OAAO,MAAM,KAAA,CAAM;IACrB;IAEA,IAAI,OAAO,UAAU,UAAU;QAC7B,OAAO,OAAO,OAAA,CAAQ,OAAO,KAAA,CAC3B,CAAC,CAAC,KAAK,IAAG,GAAM,OAAO,QAAQ,YAAY,YAAY;IAE3D;IAEA,OAAO;AACT;AAEO,SAAS,YAAY,KAAA;IAC1B,OAAO,MAAM,OAAA,CAAQ,UAAU,MAAM,KAAA,CAAM;AAC7C;AAEO,SAAS,aAAa,KAAA;IAC3B,OACE,SAAS,QACT,OAAO,UAAU,YACjB,OAAO,OAAA,CAAQ,OAAO,KAAA,CACpB,CAAC,CAAC,KAAK,IAAG,GAAM,OAAO,QAAQ,YAAY,YAAY;AAG7D"}},
    {"offset": {"line": 585, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 590, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/errors/api-call-error.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/errors/empty-response-body-error.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/errors/get-error-message.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/errors/invalid-prompt-error.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/errors/invalid-response-data-error.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/errors/load-api-key-error.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/errors/load-setting-error.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/errors/no-content-generated-error.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/errors/no-such-model-error.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/errors/too-many-embedding-values-for-call-error.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/errors/unsupported-functionality-error.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider/src/json-value/is-json.ts"],"sourcesContent":["/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n\n  /**\n   * Returns a JSON representation of the error.\n   * @returns {Object} An object containing the error's name, message, and cause.\n   *\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_APICallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class APICallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n\n  readonly responseHeaders?: Record<string, string>;\n  readonly responseBody?: string;\n\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 408 || // request timeout\n        statusCode === 409 || // conflict\n        statusCode === 429 || // too many requests\n        statusCode >= 500), // server error\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseHeaders?: Record<string, string>;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is APICallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isAPICallError(error: unknown): error is APICallError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as APICallError).url === 'string' &&\n      typeof (error as APICallError).requestBodyValues === 'object' &&\n      ((error as APICallError).statusCode == null ||\n        typeof (error as APICallError).statusCode === 'number') &&\n      ((error as APICallError).responseHeaders == null ||\n        typeof (error as APICallError).responseHeaders === 'object') &&\n      ((error as APICallError).responseBody == null ||\n        typeof (error as APICallError).responseBody === 'string') &&\n      ((error as APICallError).cause == null ||\n        typeof (error as APICallError).cause === 'object') &&\n      typeof (error as APICallError).isRetryable === 'boolean' &&\n      ((error as APICallError).data == null ||\n        typeof (error as APICallError).data === 'object')\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      requestBodyValues: this.requestBodyValues,\n      statusCode: this.statusCode,\n      responseHeaders: this.responseHeaders,\n      responseBody: this.responseBody,\n      cause: this.cause,\n      isRetryable: this.isRetryable,\n      data: this.data,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_EmptyResponseBodyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class EmptyResponseBodyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'Empty response body' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is EmptyResponseBodyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isEmptyResponseBodyError(\n    error: unknown,\n  ): error is EmptyResponseBodyError {\n    return error instanceof Error && error.name === name;\n  }\n}\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidPromptError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A prompt is invalid. This error should be thrown by providers when they cannot\n * process a prompt.\n */\nexport class InvalidPromptError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly prompt: unknown;\n\n  constructor({\n    prompt,\n    message,\n    cause,\n  }: {\n    prompt: unknown;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message: `Invalid prompt: ${message}`, cause });\n\n    this.prompt = prompt;\n  }\n\n  static isInstance(error: unknown): error is InvalidPromptError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidPromptError(error: unknown): error is InvalidPromptError {\n    return error instanceof Error && error.name === name && prompt != null;\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      prompt: this.prompt,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidResponseDataError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Server returned a response with invalid data content.\n * This should be thrown by providers when they cannot parse the response from the API.\n */\nexport class InvalidResponseDataError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly data: unknown;\n\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`,\n  }: {\n    data: unknown;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is InvalidResponseDataError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidResponseDataError(\n    error: unknown,\n  ): error is InvalidResponseDataError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      (error as InvalidResponseDataError).data != null\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      data: this.data,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isJSONParseError(error: unknown): error is JSONParseError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      'text' in error &&\n      typeof error.text === 'string'\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n\n      valueText: this.text,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadAPIKeyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadAPIKeyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadAPIKeyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadAPIKeyError(error: unknown): error is LoadAPIKeyError {\n    return error instanceof Error && error.name === name;\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadSettingError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadSettingError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadSettingError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadSettingError(error: unknown): error is LoadSettingError {\n    return error instanceof Error && error.name === name;\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoContentGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when the AI provider fails to generate any content.\n */\nexport class NoContentGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({\n    message = 'No content generated.',\n  }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoContentGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isNoContentGeneratedError(\n    error: unknown,\n  ): error is NoContentGeneratedError {\n    return error instanceof Error && error.name === name;\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      cause: this.cause,\n      message: this.message,\n      stack: this.stack,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoSuchModelError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchModelError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly modelId: string;\n  readonly modelType: 'languageModel' | 'textEmbeddingModel';\n\n  constructor({\n    errorName = name,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`,\n  }: {\n    errorName?: string;\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel';\n    message?: string;\n  }) {\n    super({ name: errorName, message });\n\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n\n  static isInstance(error: unknown): error is NoSuchModelError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchModelError(error: unknown): error is NoSuchModelError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as NoSuchModelError).modelId === 'string' &&\n      typeof (error as NoSuchModelError).modelType === 'string'\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      modelId: this.modelId,\n      modelType: this.modelType,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_TooManyEmbeddingValuesForCallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TooManyEmbeddingValuesForCallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly provider: string;\n  readonly modelId: string;\n  readonly maxEmbeddingsPerCall: number;\n  readonly values: Array<unknown>;\n\n  constructor(options: {\n    provider: string;\n    modelId: string;\n    maxEmbeddingsPerCall: number;\n    values: Array<unknown>;\n  }) {\n    super({\n      name,\n      message:\n        `Too many values for a single embedding call. ` +\n        `The ${options.provider} model \"${options.modelId}\" can only embed up to ` +\n        `${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`,\n    });\n\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n\n  static isInstance(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTooManyEmbeddingValuesForCallError(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      'provider' in error &&\n      typeof error.provider === 'string' &&\n      'modelId' in error &&\n      typeof error.modelId === 'string' &&\n      'maxEmbeddingsPerCall' in error &&\n      typeof error.maxEmbeddingsPerCall === 'number' &&\n      'values' in error &&\n      Array.isArray(error.values)\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      provider: this.provider,\n      modelId: this.modelId,\n      maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n      values: this.values,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTypeValidationError(error: unknown): error is TypeValidationError {\n    return error instanceof Error && error.name === name;\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n\n      value: this.value,\n    };\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_UnsupportedFunctionalityError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class UnsupportedFunctionalityError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly functionality: string;\n\n  constructor({ functionality }: { functionality: string }) {\n    super({\n      name,\n      message: `'${functionality}' functionality not supported.`,\n    });\n\n    this.functionality = functionality;\n  }\n\n  static isInstance(error: unknown): error is UnsupportedFunctionalityError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isUnsupportedFunctionalityError(\n    error: unknown,\n  ): error is UnsupportedFunctionalityError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as UnsupportedFunctionalityError).functionality === 'string'\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      functionality: this.functionality,\n    };\n  }\n}\n","import { JSONArray, JSONObject, JSONValue } from './json-value';\n\nexport function isJSONValue(value: unknown): value is JSONValue {\n  if (\n    value === null ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  ) {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n\n  if (typeof value === 'object') {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    );\n  }\n\n  return false;\n}\n\nexport function isJSONArray(value: unknown): value is JSONArray {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\n\nexport function isJSONObject(value: unknown): value is JSONObject {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    )\n  );\n}\n"],"names":["name","marker","symbol","_a","prompt"],"mappings":"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"}},
    {"offset": {"line": 1112, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1117, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/combine-headers.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/convert-async-generator-to-readable-stream.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/generate-id.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/get-error-message.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/load-api-key.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/load-setting.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/load-optional-setting.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/parse-json.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/validate-types.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/validator.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/post-to-api.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/response-handler.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts","/turbopack/[project]/node_modules/@ai-sdk/react/node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts"],"sourcesContent":["export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n","/**\n * Converts an AsyncGenerator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncGenerator.\n * @param {AsyncGenerator<T>} stream - The AsyncGenerator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncGenerator.\n */\nexport function convertAsyncGeneratorToReadableStream<T>(\n  stream: AsyncGenerator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await stream.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n","/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n","import { customAlphabet } from 'nanoid/non-secure';\n\n/**\n * Creates an ID generator that uses an alphabet of digits, uppercase and lowercase letters.\n *\n * @param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n * @param prefix - The prefix of the ID to generate. Default: ''.\n * @param size - The size of the random part of the ID to generate. Default: 7.\n */\n//TODO change default size to 16 in 4.0\nexport const createIdGenerator = ({\n  prefix = '',\n  size: defaultSize = 7,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n}: {\n  prefix?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n  return size => `${prefix}${generator(size)}`;\n};\n\n/**\n * Generates a 7-character random string to use for IDs. Not secure.\n *\n * @param size - The size of the ID to generate. Default: 7.\n */\n//TODO change default size to 16 in 4.0\nexport const generateId = createIdGenerator();\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n","import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n","import { LoadSettingError } from '@ai-sdk/provider';\n\n/**\n * Loads a `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @param settingName - The setting name.\n * @param description - The description of the setting.\n * @returns The setting value.\n */\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter. ` +\n        `Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter ` +\n        `or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting must be a string. ` +\n        `The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n","/**\n * Loads an optional `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @returns The setting value.\n */\nexport function loadOptionalSetting({\n  settingValue,\n  environmentVariableName,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n}): string | undefined {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null || typeof process === 'undefined') {\n    return undefined;\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null || typeof settingValue !== 'string') {\n    return undefined;\n  }\n\n  return settingValue;\n}\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isJSONParseError(error) ||\n      TypeValidationError.isTypeValidationError(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: JSONParseError | TypeValidationError } {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return {\n        success: true,\n        value: value as T,\n      };\n    }\n\n    return safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isJSONParseError(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n@deprecated Use `isParsableJson` instead.\n */\nexport const isParseableJson = isParsableJson;\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n","import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { isAbortError } from './is-abort-error';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isAPICallError(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isAPICallError(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","export function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n","import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport {\n  EventSourceParserStream,\n  ParsedEvent,\n} from 'eventsource-parser/stream';\nimport { ZodSchema } from 'zod';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { ParseResult, parseJSON, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(new EventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<ParsedEvent, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n    };\n  };\n","// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n","export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n"],"names":["validator","TypeValidationError","APICallError"],"mappings":"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"}},
    {"offset": {"line": 1646, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1651, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/combine-headers.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/convert-async-generator-to-readable-stream.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/generate-id.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/get-error-message.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/load-api-key.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/load-setting.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/load-optional-setting.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/parse-json.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/validate-types.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/validator.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/post-to-api.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/response-handler.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts"],"sourcesContent":["export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n","/**\n * Converts an AsyncGenerator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncGenerator.\n * @param {AsyncGenerator<T>} stream - The AsyncGenerator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncGenerator.\n */\nexport function convertAsyncGeneratorToReadableStream<T>(\n  stream: AsyncGenerator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await stream.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n","/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n","import { customAlphabet } from 'nanoid/non-secure';\n\n/**\n * Creates an ID generator that uses an alphabet of digits, uppercase and lowercase letters.\n *\n * @param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n * @param prefix - The prefix of the ID to generate. Default: ''.\n * @param size - The size of the random part of the ID to generate. Default: 7.\n */\n//TODO change default size to 16 in 4.0\nexport const createIdGenerator = ({\n  prefix = '',\n  size: defaultSize = 7,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n}: {\n  prefix?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n  return size => `${prefix}${generator(size)}`;\n};\n\n/**\n * Generates a 7-character random string to use for IDs. Not secure.\n *\n * @param size - The size of the ID to generate. Default: 7.\n */\n//TODO change default size to 16 in 4.0\nexport const generateId = createIdGenerator();\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n","import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n","import { LoadSettingError } from '@ai-sdk/provider';\n\n/**\n * Loads a `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @param settingName - The setting name.\n * @param description - The description of the setting.\n * @returns The setting value.\n */\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter. ` +\n        `Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter ` +\n        `or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting must be a string. ` +\n        `The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n","/**\n * Loads an optional `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @returns The setting value.\n */\nexport function loadOptionalSetting({\n  settingValue,\n  environmentVariableName,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n}): string | undefined {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null || typeof process === 'undefined') {\n    return undefined;\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null || typeof settingValue !== 'string') {\n    return undefined;\n  }\n\n  return settingValue;\n}\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isJSONParseError(error) ||\n      TypeValidationError.isTypeValidationError(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: JSONParseError | TypeValidationError } {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return {\n        success: true,\n        value: value as T,\n      };\n    }\n\n    return safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isJSONParseError(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n@deprecated Use `isParsableJson` instead.\n */\nexport const isParseableJson = isParsableJson;\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n","import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { isAbortError } from './is-abort-error';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isAPICallError(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isAPICallError(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","export function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n","import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport {\n  EventSourceParserStream,\n  ParsedEvent,\n} from 'eventsource-parser/stream';\nimport { ZodSchema } from 'zod';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { ParseResult, parseJSON, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(new EventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<ParsedEvent, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n    };\n  };\n","// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n","export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n"],"names":["validator","TypeValidationError","APICallError"],"mappings":"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"}},
    {"offset": {"line": 2180, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2185, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@ai-sdk/ui-utils/src/index.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/src/process-data-protocol-response.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/src/parse-partial-json.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/src/fix-json.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/src/stream-parts.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/src/read-data-stream.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/src/call-chat-api.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/src/call-completion-api.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/src/create-chunk-decoder.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/src/data-url.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/src/is-deep-equal-data.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/src/process-chat-stream.ts","/turbopack/[project]/node_modules/@ai-sdk/ui-utils/src/schema.ts"],"sourcesContent":["export * from './types';\n\nexport { generateId } from '@ai-sdk/provider-utils';\n\n// Export stream data utilities for custom stream implementations,\n// both on the client and server side.\n// NOTE: this is experimental / internal and may change without notice\nexport { callChatApi } from './call-chat-api';\nexport { callCompletionApi } from './call-completion-api';\nexport { createChunkDecoder } from './create-chunk-decoder';\nexport { getTextFromDataUrl } from './data-url';\nexport type { DeepPartial } from './deep-partial';\nexport { isDeepEqualData } from './is-deep-equal-data';\nexport { processDataProtocolResponse } from './process-data-protocol-response';\nexport { parsePartialJson } from './parse-partial-json';\nexport { processChatStream } from './process-chat-stream';\nexport { readDataStream } from './read-data-stream';\nexport { asSchema, jsonSchema, zodSchema } from './schema';\nexport type { Schema } from './schema';\nexport { formatStreamPart, parseStreamPart } from './stream-parts';\nexport type { StreamPart, StreamString } from './stream-parts';\n","import { generateId as generateIdFunction } from '@ai-sdk/provider-utils';\nimport { parsePartialJson } from './parse-partial-json';\nimport { readDataStream } from './read-data-stream';\nimport type {\n  FunctionCall,\n  JSONValue,\n  Message,\n  ToolCall,\n  UseChatOptions,\n} from './types';\nimport { LanguageModelV1FinishReason } from '@ai-sdk/provider';\n\ntype PrefixMap = {\n  text?: Message;\n  // @deprecated\n  function_call?: Message & {\n    role: 'assistant';\n    function_call: FunctionCall;\n  };\n  // @deprecated\n  tool_calls?: Message & {\n    role: 'assistant';\n    tool_calls: ToolCall[];\n  };\n};\n\nfunction assignAnnotationsToMessage<T extends Message | null | undefined>(\n  message: T,\n  annotations: JSONValue[] | undefined,\n): T {\n  if (!message || !annotations || !annotations.length) return message;\n  return { ...message, annotations: [...annotations] } as T;\n}\n\nexport async function processDataProtocolResponse({\n  reader,\n  abortControllerRef,\n  update,\n  onToolCall,\n  onFinish,\n  generateId = generateIdFunction,\n  getCurrentDate = () => new Date(),\n}: {\n  reader: ReadableStreamDefaultReader<Uint8Array>;\n  abortControllerRef?: {\n    current: AbortController | null;\n  };\n  update: (newMessages: Message[], data: JSONValue[] | undefined) => void;\n  onToolCall?: UseChatOptions['onToolCall'];\n  onFinish?: (options: {\n    message: Message | undefined;\n    finishReason: LanguageModelV1FinishReason;\n    usage: {\n      completionTokens: number;\n      promptTokens: number;\n      totalTokens: number;\n    };\n  }) => void;\n  generateId?: () => string;\n  getCurrentDate?: () => Date;\n}) {\n  const createdAt = getCurrentDate();\n\n  let prefixMap: PrefixMap = {};\n  let nextPrefixMap: PrefixMap | undefined = undefined;\n\n  const previousMessages: Message[] = [];\n\n  const data: JSONValue[] = [];\n\n  // keep list of current message annotations for message\n  let message_annotations: JSONValue[] | undefined = undefined;\n\n  // keep track of partial tool calls\n  const partialToolCalls: Record<\n    string,\n    { text: string; prefixMapIndex: number; toolName: string }\n  > = {};\n\n  let usage: {\n    completionTokens: number;\n    promptTokens: number;\n    totalTokens: number;\n  } = {\n    completionTokens: NaN,\n    promptTokens: NaN,\n    totalTokens: NaN,\n  };\n  let finishReason: LanguageModelV1FinishReason = 'unknown';\n\n  // we create a map of each prefix, and for each prefixed message we push to the map\n  for await (const { type, value } of readDataStream(reader, {\n    isAborted: () => abortControllerRef?.current === null,\n  })) {\n    if (type === 'error') {\n      throw new Error(value);\n    }\n\n    if (type === 'finish_step') {\n      if (!value.isContinued) {\n        nextPrefixMap = {};\n      }\n      continue;\n    }\n\n    if (type === 'finish_message') {\n      finishReason = value.finishReason;\n\n      if (value.usage != null) {\n        const { completionTokens, promptTokens } = value.usage;\n\n        usage = {\n          completionTokens,\n          promptTokens,\n          totalTokens: completionTokens + promptTokens,\n        };\n      }\n\n      continue;\n    }\n\n    if (nextPrefixMap) {\n      if (prefixMap.text) {\n        previousMessages.push(prefixMap.text);\n      }\n      if (prefixMap.function_call) {\n        previousMessages.push(prefixMap.function_call);\n      }\n      if (prefixMap.tool_calls) {\n        previousMessages.push(prefixMap.tool_calls);\n      }\n\n      prefixMap = nextPrefixMap;\n      nextPrefixMap = undefined;\n    }\n\n    if (type === 'text') {\n      if (prefixMap['text']) {\n        prefixMap['text'] = {\n          ...prefixMap['text'],\n          content: (prefixMap['text'].content || '') + value,\n        };\n      } else {\n        prefixMap['text'] = {\n          id: generateId(),\n          role: 'assistant',\n          content: value,\n          createdAt,\n        };\n      }\n    }\n\n    // Tool invocations are part of an assistant message\n    if (type === 'tool_call_streaming_start') {\n      // create message if it doesn't exist\n      if (prefixMap.text == null) {\n        prefixMap.text = {\n          id: generateId(),\n          role: 'assistant',\n          content: '',\n          createdAt,\n        };\n      }\n\n      if (prefixMap.text.toolInvocations == null) {\n        prefixMap.text.toolInvocations = [];\n      }\n\n      // add the partial tool call to the map\n      partialToolCalls[value.toolCallId] = {\n        text: '',\n        toolName: value.toolName,\n        prefixMapIndex: prefixMap.text.toolInvocations.length,\n      };\n\n      prefixMap.text.toolInvocations.push({\n        state: 'partial-call',\n        toolCallId: value.toolCallId,\n        toolName: value.toolName,\n        args: undefined,\n      });\n    } else if (type === 'tool_call_delta') {\n      const partialToolCall = partialToolCalls[value.toolCallId];\n\n      partialToolCall.text += value.argsTextDelta;\n\n      const { value: partialArgs } = parsePartialJson(partialToolCall.text);\n\n      prefixMap.text!.toolInvocations![partialToolCall.prefixMapIndex] = {\n        state: 'partial-call',\n        toolCallId: value.toolCallId,\n        toolName: partialToolCall.toolName,\n        args: partialArgs,\n      };\n\n      // trigger update for streaming by copying adding a update id that changes\n      // (without it, the changes get stuck in SWR and are not forwarded to rendering):\n      (prefixMap.text! as any).internalUpdateId = generateId();\n    } else if (type === 'tool_call') {\n      if (partialToolCalls[value.toolCallId] != null) {\n        // change the partial tool call to a full tool call\n        prefixMap.text!.toolInvocations![\n          partialToolCalls[value.toolCallId].prefixMapIndex\n        ] = { state: 'call', ...value };\n      } else {\n        // create message if it doesn't exist\n        if (prefixMap.text == null) {\n          prefixMap.text = {\n            id: generateId(),\n            role: 'assistant',\n            content: '',\n            createdAt,\n          };\n        }\n\n        if (prefixMap.text.toolInvocations == null) {\n          prefixMap.text.toolInvocations = [];\n        }\n\n        prefixMap.text.toolInvocations.push({\n          state: 'call',\n          ...value,\n        });\n      }\n\n      // trigger update for streaming by copying adding a update id that changes\n      // (without it, the changes get stuck in SWR and are not forwarded to rendering):\n      (prefixMap.text! as any).internalUpdateId = generateId();\n\n      // invoke the onToolCall callback if it exists. This is blocking.\n      // In the future we should make this non-blocking, which\n      // requires additional state management for error handling etc.\n      if (onToolCall) {\n        const result = await onToolCall({ toolCall: value });\n        if (result != null) {\n          // store the result in the tool invocation\n          prefixMap.text!.toolInvocations![\n            prefixMap.text!.toolInvocations!.length - 1\n          ] = { state: 'result', ...value, result };\n        }\n      }\n    } else if (type === 'tool_result') {\n      const toolInvocations = prefixMap.text?.toolInvocations;\n\n      if (toolInvocations == null) {\n        throw new Error('tool_result must be preceded by a tool_call');\n      }\n\n      // find if there is any tool invocation with the same toolCallId\n      // and replace it with the result\n      const toolInvocationIndex = toolInvocations.findIndex(\n        invocation => invocation.toolCallId === value.toolCallId,\n      );\n\n      if (toolInvocationIndex === -1) {\n        throw new Error(\n          'tool_result must be preceded by a tool_call with the same toolCallId',\n        );\n      }\n\n      toolInvocations[toolInvocationIndex] = {\n        ...toolInvocations[toolInvocationIndex],\n        state: 'result' as const,\n        ...value,\n      };\n    }\n\n    let functionCallMessage: Message | null | undefined = null;\n\n    if (type === 'function_call') {\n      prefixMap['function_call'] = {\n        id: generateId(),\n        role: 'assistant',\n        content: '',\n        function_call: value.function_call,\n        name: value.function_call.name,\n        createdAt,\n      };\n\n      functionCallMessage = prefixMap['function_call'];\n    }\n\n    let toolCallMessage: Message | null | undefined = null;\n\n    if (type === 'tool_calls') {\n      prefixMap['tool_calls'] = {\n        id: generateId(),\n        role: 'assistant',\n        content: '',\n        tool_calls: value.tool_calls,\n        createdAt,\n      };\n\n      toolCallMessage = prefixMap['tool_calls'];\n    }\n\n    if (type === 'data') {\n      data.push(...value);\n    }\n\n    let responseMessage = prefixMap['text'];\n\n    if (type === 'message_annotations') {\n      if (!message_annotations) {\n        message_annotations = [...value];\n      } else {\n        message_annotations.push(...value);\n      }\n\n      // Update any existing message with the latest annotations\n      functionCallMessage = assignAnnotationsToMessage(\n        prefixMap['function_call'],\n        message_annotations,\n      );\n      toolCallMessage = assignAnnotationsToMessage(\n        prefixMap['tool_calls'],\n        message_annotations,\n      );\n      responseMessage = assignAnnotationsToMessage(\n        prefixMap['text'],\n        message_annotations,\n      );\n    }\n\n    // keeps the prefixMap up to date with the latest annotations, even if annotations preceded the message\n    if (message_annotations?.length) {\n      if (prefixMap.text) {\n        prefixMap.text.annotations = [...message_annotations!];\n      }\n      if (prefixMap.function_call) {\n        prefixMap.function_call.annotations = [...message_annotations!];\n      }\n      if (prefixMap.tool_calls) {\n        prefixMap.tool_calls.annotations = [...message_annotations!];\n      }\n    }\n\n    // We add function & tool calls and response messages to the messages[], but data is its own thing\n    const merged = [functionCallMessage, toolCallMessage, responseMessage]\n      .filter(Boolean)\n      .map(message => ({\n        ...assignAnnotationsToMessage(message, message_annotations),\n      })) as Message[];\n\n    update([...previousMessages, ...merged], [...data]); // make a copy of the data array\n  }\n\n  onFinish?.({ message: prefixMap.text, finishReason, usage });\n\n  return {\n    messages: [\n      prefixMap.text,\n      prefixMap.function_call,\n      prefixMap.tool_calls,\n    ].filter(Boolean) as Message[],\n    data,\n  };\n}\n","import { JSONValue } from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { fixJson } from './fix-json';\n\nexport function parsePartialJson(jsonText: string | undefined): {\n  value: JSONValue | undefined;\n  state:\n    | 'undefined-input'\n    | 'successful-parse'\n    | 'repaired-parse'\n    | 'failed-parse';\n} {\n  if (jsonText === undefined) {\n    return { value: undefined, state: 'undefined-input' };\n  }\n\n  try {\n    // first attempt a regular JSON parse:\n    return {\n      value: SecureJSON.parse(jsonText),\n      state: 'successful-parse',\n    };\n  } catch (ignored) {\n    try {\n      // then try to fix the partial JSON and parse it:\n      return {\n        value: SecureJSON.parse(fixJson(jsonText)),\n        state: 'repaired-parse',\n      };\n    } catch (ignored) {\n      // ignored\n    }\n  }\n\n  return { value: undefined, state: 'failed-parse' };\n}\n","type State =\n  | 'ROOT'\n  | 'FINISH'\n  | 'INSIDE_STRING'\n  | 'INSIDE_STRING_ESCAPE'\n  | 'INSIDE_LITERAL'\n  | 'INSIDE_NUMBER'\n  | 'INSIDE_OBJECT_START'\n  | 'INSIDE_OBJECT_KEY'\n  | 'INSIDE_OBJECT_AFTER_KEY'\n  | 'INSIDE_OBJECT_BEFORE_VALUE'\n  | 'INSIDE_OBJECT_AFTER_VALUE'\n  | 'INSIDE_OBJECT_AFTER_COMMA'\n  | 'INSIDE_ARRAY_START'\n  | 'INSIDE_ARRAY_AFTER_VALUE'\n  | 'INSIDE_ARRAY_AFTER_COMMA';\n\n// Implemented as a scanner with additional fixing\n// that performs a single linear time scan pass over the partial JSON.\n//\n// The states should ideally match relevant states from the JSON spec:\n// https://www.json.org/json-en.html\n//\n// Please note that invalid JSON is not considered/covered, because it\n// is assumed that the resulting JSON will be processed by a standard\n// JSON parser that will detect any invalid JSON.\nexport function fixJson(input: string): string {\n  const stack: State[] = ['ROOT'];\n  let lastValidIndex = -1;\n  let literalStart: number | null = null;\n\n  function processValueStart(char: string, i: number, swapState: State) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_STRING');\n          break;\n        }\n\n        case 'f':\n        case 't':\n        case 'n': {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_LITERAL');\n          break;\n        }\n\n        case '-': {\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n\n        case '{': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_OBJECT_START');\n          break;\n        }\n\n        case '[': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_ARRAY_START');\n          break;\n        }\n      }\n    }\n  }\n\n  function processAfterObjectValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_OBJECT_AFTER_COMMA');\n        break;\n      }\n      case '}': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  function processAfterArrayValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_ARRAY_AFTER_COMMA');\n        break;\n      }\n      case ']': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n\n    switch (currentState) {\n      case 'ROOT':\n        processValueStart(char, i, 'FINISH');\n        break;\n\n      case 'INSIDE_OBJECT_START': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n          case '}': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_COMMA': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_AFTER_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_KEY': {\n        switch (char) {\n          case ':': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_BEFORE_VALUE');\n\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_BEFORE_VALUE': {\n        processValueStart(char, i, 'INSIDE_OBJECT_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        processAfterObjectValue(char, i);\n        break;\n      }\n\n      case 'INSIDE_STRING': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n\n          case '\\\\': {\n            stack.push('INSIDE_STRING_ESCAPE');\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START': {\n        switch (char) {\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        switch (char) {\n          case ',': {\n            stack.pop();\n            stack.push('INSIDE_ARRAY_AFTER_COMMA');\n            break;\n          }\n\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_COMMA': {\n        processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_STRING_ESCAPE': {\n        stack.pop();\n        lastValidIndex = i;\n\n        break;\n      }\n\n      case 'INSIDE_NUMBER': {\n        switch (char) {\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9': {\n            lastValidIndex = i;\n            break;\n          }\n\n          case 'e':\n          case 'E':\n          case '-':\n          case '.': {\n            break;\n          }\n\n          case ',': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case '}': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case ']': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            break;\n          }\n\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, i + 1);\n\n        if (\n          !'false'.startsWith(partialLiteral) &&\n          !'true'.startsWith(partialLiteral) &&\n          !'null'.startsWith(partialLiteral)\n        ) {\n          stack.pop();\n\n          if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n\n        break;\n      }\n    }\n  }\n\n  let result = input.slice(0, lastValidIndex + 1);\n\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n\n    switch (state) {\n      case 'INSIDE_STRING': {\n        result += '\"';\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY':\n      case 'INSIDE_OBJECT_AFTER_KEY':\n      case 'INSIDE_OBJECT_AFTER_COMMA':\n      case 'INSIDE_OBJECT_START':\n      case 'INSIDE_OBJECT_BEFORE_VALUE':\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        result += '}';\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START':\n      case 'INSIDE_ARRAY_AFTER_COMMA':\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        result += ']';\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, input.length);\n\n        if ('true'.startsWith(partialLiteral)) {\n          result += 'true'.slice(partialLiteral.length);\n        } else if ('false'.startsWith(partialLiteral)) {\n          result += 'false'.slice(partialLiteral.length);\n        } else if ('null'.startsWith(partialLiteral)) {\n          result += 'null'.slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n","import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\nimport { ToolCall as CoreToolCall } from './duplicated/tool-call';\nimport { ToolResult as CoreToolResult } from './duplicated/tool-result';\nimport {\n  AssistantMessage,\n  DataMessage,\n  FunctionCall,\n  JSONValue,\n  ToolCall,\n} from './types';\n\nexport type StreamString =\n  `${(typeof StreamStringPrefixes)[keyof typeof StreamStringPrefixes]}:${string}\\n`;\n\nexport interface StreamPart<CODE extends string, NAME extends string, TYPE> {\n  code: CODE;\n  name: NAME;\n  parse: (value: JSONValue) => { type: NAME; value: TYPE };\n}\n\nconst textStreamPart: StreamPart<'0', 'text', string> = {\n  code: '0',\n  name: 'text',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: 'text', value };\n  },\n};\n\nconst functionCallStreamPart: StreamPart<\n  '1',\n  'function_call',\n  { function_call: FunctionCall }\n> = {\n  code: '1',\n  name: 'function_call',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('function_call' in value) ||\n      typeof value.function_call !== 'object' ||\n      value.function_call == null ||\n      !('name' in value.function_call) ||\n      !('arguments' in value.function_call) ||\n      typeof value.function_call.name !== 'string' ||\n      typeof value.function_call.arguments !== 'string'\n    ) {\n      throw new Error(\n        '\"function_call\" parts expect an object with a \"function_call\" property.',\n      );\n    }\n\n    return {\n      type: 'function_call',\n      value: value as unknown as { function_call: FunctionCall },\n    };\n  },\n};\n\nconst dataStreamPart: StreamPart<'2', 'data', Array<JSONValue>> = {\n  code: '2',\n  name: 'data',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n\n    return { type: 'data', value };\n  },\n};\n\nconst errorStreamPart: StreamPart<'3', 'error', string> = {\n  code: '3',\n  name: 'error',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: 'error', value };\n  },\n};\n\nconst assistantMessageStreamPart: StreamPart<\n  '4',\n  'assistant_message',\n  AssistantMessage\n> = {\n  code: '4',\n  name: 'assistant_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('id' in value) ||\n      !('role' in value) ||\n      !('content' in value) ||\n      typeof value.id !== 'string' ||\n      typeof value.role !== 'string' ||\n      value.role !== 'assistant' ||\n      !Array.isArray(value.content) ||\n      !value.content.every(\n        item =>\n          item != null &&\n          typeof item === 'object' &&\n          'type' in item &&\n          item.type === 'text' &&\n          'text' in item &&\n          item.text != null &&\n          typeof item.text === 'object' &&\n          'value' in item.text &&\n          typeof item.text.value === 'string',\n      )\n    ) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.',\n      );\n    }\n\n    return {\n      type: 'assistant_message',\n      value: value as AssistantMessage,\n    };\n  },\n};\n\nconst assistantControlDataStreamPart: StreamPart<\n  '5',\n  'assistant_control_data',\n  {\n    threadId: string;\n    messageId: string;\n  }\n> = {\n  code: '5',\n  name: 'assistant_control_data',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('threadId' in value) ||\n      !('messageId' in value) ||\n      typeof value.threadId !== 'string' ||\n      typeof value.messageId !== 'string'\n    ) {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.',\n      );\n    }\n\n    return {\n      type: 'assistant_control_data',\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId,\n      },\n    };\n  },\n};\n\nconst dataMessageStreamPart: StreamPart<'6', 'data_message', DataMessage> = {\n  code: '6',\n  name: 'data_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('role' in value) ||\n      !('data' in value) ||\n      typeof value.role !== 'string' ||\n      value.role !== 'data'\n    ) {\n      throw new Error(\n        '\"data_message\" parts expect an object with a \"role\" and \"data\" property.',\n      );\n    }\n\n    return {\n      type: 'data_message',\n      value: value as DataMessage,\n    };\n  },\n};\n\nconst toolCallsStreamPart: StreamPart<\n  '7',\n  'tool_calls',\n  { tool_calls: ToolCall[] }\n> = {\n  code: '7',\n  name: 'tool_calls',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('tool_calls' in value) ||\n      typeof value.tool_calls !== 'object' ||\n      value.tool_calls == null ||\n      !Array.isArray(value.tool_calls) ||\n      value.tool_calls.some(\n        tc =>\n          tc == null ||\n          typeof tc !== 'object' ||\n          !('id' in tc) ||\n          typeof tc.id !== 'string' ||\n          !('type' in tc) ||\n          typeof tc.type !== 'string' ||\n          !('function' in tc) ||\n          tc.function == null ||\n          typeof tc.function !== 'object' ||\n          !('arguments' in tc.function) ||\n          typeof tc.function.name !== 'string' ||\n          typeof tc.function.arguments !== 'string',\n      )\n    ) {\n      throw new Error(\n        '\"tool_calls\" parts expect an object with a ToolCallPayload.',\n      );\n    }\n\n    return {\n      type: 'tool_calls',\n      value: value as unknown as { tool_calls: ToolCall[] },\n    };\n  },\n};\n\nconst messageAnnotationsStreamPart: StreamPart<\n  '8',\n  'message_annotations',\n  Array<JSONValue>\n> = {\n  code: '8',\n  name: 'message_annotations',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n\n    return { type: 'message_annotations', value };\n  },\n};\n\nconst toolCallStreamPart: StreamPart<\n  '9',\n  'tool_call',\n  CoreToolCall<string, any>\n> = {\n  code: '9',\n  name: 'tool_call',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string' ||\n      !('args' in value) ||\n      typeof value.args !== 'object'\n    ) {\n      throw new Error(\n        '\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call',\n      value: value as unknown as CoreToolCall<string, any>,\n    };\n  },\n};\n\nconst toolResultStreamPart: StreamPart<\n  'a',\n  'tool_result',\n  Omit<CoreToolResult<string, any, any>, 'args' | 'toolName'>\n> = {\n  code: 'a',\n  name: 'tool_result',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('result' in value)\n    ) {\n      throw new Error(\n        '\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_result',\n      value: value as unknown as Omit<\n        CoreToolResult<string, any, any>,\n        'args' | 'toolName'\n      >,\n    };\n  },\n};\n\nconst toolCallStreamingStartStreamPart: StreamPart<\n  'b',\n  'tool_call_streaming_start',\n  { toolCallId: string; toolName: string }\n> = {\n  code: 'b',\n  name: 'tool_call_streaming_start',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string'\n    ) {\n      throw new Error(\n        '\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call_streaming_start',\n      value: value as unknown as { toolCallId: string; toolName: string },\n    };\n  },\n};\n\nconst toolCallDeltaStreamPart: StreamPart<\n  'c',\n  'tool_call_delta',\n  { toolCallId: string; argsTextDelta: string }\n> = {\n  code: 'c',\n  name: 'tool_call_delta',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('argsTextDelta' in value) ||\n      typeof value.argsTextDelta !== 'string'\n    ) {\n      throw new Error(\n        '\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call_delta',\n      value: value as unknown as {\n        toolCallId: string;\n        argsTextDelta: string;\n      },\n    };\n  },\n};\n\nconst finishMessageStreamPart: StreamPart<\n  'd',\n  'finish_message',\n  {\n    finishReason: LanguageModelV1FinishReason;\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n    };\n  }\n> = {\n  code: 'd',\n  name: 'finish_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('finishReason' in value) ||\n      typeof value.finishReason !== 'string'\n    ) {\n      throw new Error(\n        '\"finish_message\" parts expect an object with a \"finishReason\" property.',\n      );\n    }\n\n    const result: {\n      finishReason: LanguageModelV1FinishReason;\n      usage?: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n    } = {\n      finishReason: value.finishReason as LanguageModelV1FinishReason,\n    };\n\n    if (\n      'usage' in value &&\n      value.usage != null &&\n      typeof value.usage === 'object' &&\n      'promptTokens' in value.usage &&\n      'completionTokens' in value.usage\n    ) {\n      result.usage = {\n        promptTokens:\n          typeof value.usage.promptTokens === 'number'\n            ? value.usage.promptTokens\n            : Number.NaN,\n        completionTokens:\n          typeof value.usage.completionTokens === 'number'\n            ? value.usage.completionTokens\n            : Number.NaN,\n      };\n    }\n\n    return {\n      type: 'finish_message',\n      value: result,\n    };\n  },\n};\n\nconst finishStepStreamPart: StreamPart<\n  'e',\n  'finish_step',\n  {\n    isContinued: boolean;\n    finishReason: LanguageModelV1FinishReason;\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n    };\n  }\n> = {\n  code: 'e',\n  name: 'finish_step',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('finishReason' in value) ||\n      typeof value.finishReason !== 'string'\n    ) {\n      throw new Error(\n        '\"finish_step\" parts expect an object with a \"finishReason\" property.',\n      );\n    }\n\n    const result: {\n      isContinued: boolean;\n      finishReason: LanguageModelV1FinishReason;\n      usage?: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n    } = {\n      finishReason: value.finishReason as LanguageModelV1FinishReason,\n      isContinued: false,\n    };\n\n    if (\n      'usage' in value &&\n      value.usage != null &&\n      typeof value.usage === 'object' &&\n      'promptTokens' in value.usage &&\n      'completionTokens' in value.usage\n    ) {\n      result.usage = {\n        promptTokens:\n          typeof value.usage.promptTokens === 'number'\n            ? value.usage.promptTokens\n            : Number.NaN,\n        completionTokens:\n          typeof value.usage.completionTokens === 'number'\n            ? value.usage.completionTokens\n            : Number.NaN,\n      };\n    }\n\n    if ('isContinued' in value && typeof value.isContinued === 'boolean') {\n      result.isContinued = value.isContinued;\n    }\n\n    return {\n      type: 'finish_step',\n      value: result,\n    };\n  },\n};\n\nconst streamParts = [\n  textStreamPart,\n  functionCallStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  assistantMessageStreamPart,\n  assistantControlDataStreamPart,\n  dataMessageStreamPart,\n  toolCallsStreamPart,\n  messageAnnotationsStreamPart,\n  toolCallStreamPart,\n  toolResultStreamPart,\n  toolCallStreamingStartStreamPart,\n  toolCallDeltaStreamPart,\n  finishMessageStreamPart,\n  finishStepStreamPart,\n] as const;\n\n// union type of all stream parts\ntype StreamParts =\n  | typeof textStreamPart\n  | typeof functionCallStreamPart\n  | typeof dataStreamPart\n  | typeof errorStreamPart\n  | typeof assistantMessageStreamPart\n  | typeof assistantControlDataStreamPart\n  | typeof dataMessageStreamPart\n  | typeof toolCallsStreamPart\n  | typeof messageAnnotationsStreamPart\n  | typeof toolCallStreamPart\n  | typeof toolResultStreamPart\n  | typeof toolCallStreamingStartStreamPart\n  | typeof toolCallDeltaStreamPart\n  | typeof finishMessageStreamPart\n  | typeof finishStepStreamPart;\n\n/**\n * Maps the type of a stream part to its value type.\n */\ntype StreamPartValueType = {\n  [P in StreamParts as P['name']]: ReturnType<P['parse']>['value'];\n};\n\nexport type StreamPartType =\n  | ReturnType<typeof textStreamPart.parse>\n  | ReturnType<typeof functionCallStreamPart.parse>\n  | ReturnType<typeof dataStreamPart.parse>\n  | ReturnType<typeof errorStreamPart.parse>\n  | ReturnType<typeof assistantMessageStreamPart.parse>\n  | ReturnType<typeof assistantControlDataStreamPart.parse>\n  | ReturnType<typeof dataMessageStreamPart.parse>\n  | ReturnType<typeof toolCallsStreamPart.parse>\n  | ReturnType<typeof messageAnnotationsStreamPart.parse>\n  | ReturnType<typeof toolCallStreamPart.parse>\n  | ReturnType<typeof toolResultStreamPart.parse>\n  | ReturnType<typeof toolCallStreamingStartStreamPart.parse>\n  | ReturnType<typeof toolCallDeltaStreamPart.parse>\n  | ReturnType<typeof finishMessageStreamPart.parse>\n  | ReturnType<typeof finishStepStreamPart.parse>;\n\nexport const streamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [functionCallStreamPart.code]: functionCallStreamPart,\n  [dataStreamPart.code]: dataStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart,\n  [toolCallsStreamPart.code]: toolCallsStreamPart,\n  [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart,\n  [toolCallStreamPart.code]: toolCallStreamPart,\n  [toolResultStreamPart.code]: toolResultStreamPart,\n  [toolCallStreamingStartStreamPart.code]: toolCallStreamingStartStreamPart,\n  [toolCallDeltaStreamPart.code]: toolCallDeltaStreamPart,\n  [finishMessageStreamPart.code]: finishMessageStreamPart,\n  [finishStepStreamPart.code]: finishStepStreamPart,\n} as const;\n\n/**\n * The map of prefixes for data in the stream\n *\n * - 0: Text from the LLM response\n * - 1: (OpenAI) function_call responses\n * - 2: custom JSON added by the user using `Data`\n * - 6: (OpenAI) tool_call responses\n *\n * Example:\n * ```\n * 0:Vercel\n * 0:'s\n * 0: AI\n * 0: AI\n * 0: SDK\n * 0: is great\n * 0:!\n * 2: { \"someJson\": \"value\" }\n * 1: {\"function_call\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}\n * 6: {\"tool_call\": {\"id\": \"tool_0\", \"type\": \"function\", \"function\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}}\n *```\n */\nexport const StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [functionCallStreamPart.name]: functionCallStreamPart.code,\n  [dataStreamPart.name]: dataStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n  [toolCallsStreamPart.name]: toolCallsStreamPart.code,\n  [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code,\n  [toolCallStreamPart.name]: toolCallStreamPart.code,\n  [toolResultStreamPart.name]: toolResultStreamPart.code,\n  [toolCallStreamingStartStreamPart.name]:\n    toolCallStreamingStartStreamPart.code,\n  [toolCallDeltaStreamPart.name]: toolCallDeltaStreamPart.code,\n  [finishMessageStreamPart.name]: finishMessageStreamPart.code,\n  [finishStepStreamPart.name]: finishStepStreamPart.code,\n} as const;\n\nexport const validCodes = streamParts.map(part => part.code);\n\n/**\nParses a stream part from a string.\n\n@param line The string to parse.\n@returns The parsed stream part.\n@throws An error if the string cannot be parsed.\n */\nexport const parseStreamPart = (line: string): StreamPartType => {\n  const firstSeparatorIndex = line.indexOf(':');\n\n  if (firstSeparatorIndex === -1) {\n    throw new Error('Failed to parse stream string. No separator found.');\n  }\n\n  const prefix = line.slice(0, firstSeparatorIndex);\n\n  if (!validCodes.includes(prefix as keyof typeof streamPartsByCode)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n\n  const code = prefix as keyof typeof streamPartsByCode;\n\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue: JSONValue = JSON.parse(textValue);\n\n  return streamPartsByCode[code].parse(jsonValue);\n};\n\n/**\nPrepends a string with a prefix from the `StreamChunkPrefixes`, JSON-ifies it,\nand appends a new line.\n\nIt ensures type-safety for the part type and value.\n */\nexport function formatStreamPart<T extends keyof StreamPartValueType>(\n  type: T,\n  value: StreamPartValueType[T],\n): StreamString {\n  const streamPart = streamParts.find(part => part.name === type);\n\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n\n  return `${streamPart.code}:${JSON.stringify(value)}\\n`;\n}\n","import { StreamPartType, parseStreamPart } from './stream-parts';\n\nconst NEWLINE = '\\n'.charCodeAt(0);\n\n// concatenates all the chunks into a single Uint8Array\nfunction concatChunks(chunks: Uint8Array[], totalLength: number) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n\n  return concatenatedChunks;\n}\n\n/**\nConverts a ReadableStreamDefaultReader into an async generator that yields\nStreamPart objects.\n\n@param reader\n       Reader for the stream to read from.\n@param isAborted\n       Optional function that returns true if the request has been aborted.\n       If the function returns true, the generator will stop reading the stream.\n       If the function is not provided, the generator will not stop reading the stream.\n */\nexport async function* readDataStream(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n  {\n    isAborted,\n  }: {\n    isAborted?: () => boolean;\n  } = {},\n): AsyncGenerator<StreamPartType> {\n  // implementation note: this slightly more complex algorithm is required\n  // to pass the tests in the edge environment.\n\n  const decoder = new TextDecoder();\n  const chunks: Uint8Array[] = [];\n  let totalLength = 0;\n\n  while (true) {\n    const { value } = await reader.read();\n\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        // if the last character is not a newline, we have not read the whole JSON value\n        continue;\n      }\n    }\n\n    if (chunks.length === 0) {\n      break; // we have reached the end of the stream\n    }\n\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n\n    const streamParts = decoder\n      .decode(concatenatedChunks, { stream: true })\n      .split('\\n')\n      .filter(line => line !== '') // splitting leaves an empty string at the end\n      .map(parseStreamPart);\n\n    for (const streamPart of streamParts) {\n      yield streamPart;\n    }\n\n    // The request has been aborted, stop reading the stream.\n    if (isAborted?.()) {\n      reader.cancel();\n      break;\n    }\n  }\n}\n","import { createChunkDecoder } from './index';\nimport { processDataProtocolResponse } from './process-data-protocol-response';\nimport { IdGenerator, JSONValue, Message, UseChatOptions } from './types';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport async function callChatApi({\n  api,\n  body,\n  streamProtocol = 'data',\n  credentials,\n  headers,\n  abortController,\n  restoreMessagesOnFailure,\n  onResponse,\n  onUpdate,\n  onFinish,\n  onToolCall,\n  generateId,\n  fetch = getOriginalFetch(),\n}: {\n  api: string;\n  body: Record<string, any>;\n  streamProtocol: 'data' | 'text' | undefined;\n  credentials: RequestCredentials | undefined;\n  headers: HeadersInit | undefined;\n  abortController: (() => AbortController | null) | undefined;\n  restoreMessagesOnFailure: () => void;\n  onResponse: ((response: Response) => void | Promise<void>) | undefined;\n  onUpdate: (newMessages: Message[], data: JSONValue[] | undefined) => void;\n  onFinish: UseChatOptions['onFinish'];\n  onToolCall: UseChatOptions['onToolCall'];\n  generateId: IdGenerator;\n  fetch: ReturnType<typeof getOriginalFetch> | undefined;\n}) {\n  const response = await fetch(api, {\n    method: 'POST',\n    body: JSON.stringify(body),\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    signal: abortController?.()?.signal,\n    credentials,\n  }).catch(err => {\n    restoreMessagesOnFailure();\n    throw err;\n  });\n\n  if (onResponse) {\n    try {\n      await onResponse(response);\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  if (!response.ok) {\n    restoreMessagesOnFailure();\n    throw new Error(\n      (await response.text()) ?? 'Failed to fetch the chat response.',\n    );\n  }\n\n  if (!response.body) {\n    throw new Error('The response body is empty.');\n  }\n\n  const reader = response.body.getReader();\n\n  switch (streamProtocol) {\n    case 'text': {\n      const decoder = createChunkDecoder();\n\n      const resultMessage = {\n        id: generateId(),\n        createdAt: new Date(),\n        role: 'assistant' as const,\n        content: '',\n      };\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          break;\n        }\n\n        resultMessage.content += decoder(value);\n\n        // note: creating a new message object is required for Solid.js streaming\n        onUpdate([{ ...resultMessage }], []);\n\n        // The request has been aborted, stop reading the stream.\n        if (abortController?.() === null) {\n          reader.cancel();\n          break;\n        }\n      }\n\n      // in text mode, we don't have usage information or finish reason:\n      onFinish?.(resultMessage, {\n        usage: { completionTokens: NaN, promptTokens: NaN, totalTokens: NaN },\n        finishReason: 'unknown',\n      });\n\n      return {\n        messages: [resultMessage],\n        data: [],\n      };\n    }\n\n    case 'data': {\n      return await processDataProtocolResponse({\n        reader,\n        abortControllerRef:\n          abortController != null ? { current: abortController() } : undefined,\n        update: onUpdate,\n        onToolCall,\n        onFinish({ message, finishReason, usage }) {\n          if (onFinish && message != null) {\n            onFinish(message, { usage, finishReason });\n          }\n        },\n        generateId,\n      });\n    }\n\n    default: {\n      const exhaustiveCheck: never = streamProtocol;\n      throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n    }\n  }\n}\n","import { readDataStream } from './read-data-stream';\nimport { JSONValue } from './types';\nimport { createChunkDecoder } from './index';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport async function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = 'data',\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onResponse,\n  onFinish,\n  onError,\n  onData,\n  fetch = getOriginalFetch(),\n}: {\n  api: string;\n  prompt: string;\n  credentials: RequestCredentials | undefined;\n  headers: HeadersInit | undefined;\n  body: Record<string, any>;\n  streamProtocol: 'data' | 'text' | undefined;\n  setCompletion: (completion: string) => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: Error | undefined) => void;\n  setAbortController: (abortController: AbortController | null) => void;\n  onResponse: ((response: Response) => void | Promise<void>) | undefined;\n  onFinish: ((prompt: string, completion: string) => void) | undefined;\n  onError: ((error: Error) => void) | undefined;\n  onData: ((data: JSONValue[]) => void) | undefined;\n  fetch: ReturnType<typeof getOriginalFetch> | undefined;\n}) {\n  try {\n    setLoading(true);\n    setError(undefined);\n\n    const abortController = new AbortController();\n    setAbortController(abortController);\n\n    // Empty the completion immediately.\n    setCompletion('');\n\n    const res = await fetch(api, {\n      method: 'POST',\n      body: JSON.stringify({\n        prompt,\n        ...body,\n      }),\n      credentials,\n      headers: {\n        'Content-Type': 'application/json',\n        ...headers,\n      },\n      signal: abortController.signal,\n    }).catch(err => {\n      throw err;\n    });\n\n    if (onResponse) {\n      try {\n        await onResponse(res);\n      } catch (err) {\n        throw err;\n      }\n    }\n\n    if (!res.ok) {\n      throw new Error(\n        (await res.text()) || 'Failed to fetch the chat response.',\n      );\n    }\n\n    if (!res.body) {\n      throw new Error('The response body is empty.');\n    }\n\n    let result = '';\n    const reader = res.body.getReader();\n\n    switch (streamProtocol) {\n      case 'text': {\n        const decoder = createChunkDecoder();\n\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {\n            break;\n          }\n\n          // Update the completion state with the new message tokens.\n          result += decoder(value);\n          setCompletion(result);\n\n          // The request has been aborted, stop reading the stream.\n          if (abortController === null) {\n            reader.cancel();\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'data': {\n        for await (const { type, value } of readDataStream(reader, {\n          isAborted: () => abortController === null,\n        })) {\n          switch (type) {\n            case 'text': {\n              result += value;\n              setCompletion(result);\n              break;\n            }\n            case 'data': {\n              onData?.(value);\n              break;\n            }\n          }\n        }\n        break;\n      }\n\n      default: {\n        const exhaustiveCheck: never = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    // Ignore abort errors as they are expected.\n    if ((err as any).name === 'AbortError') {\n      setAbortController(null);\n      return null;\n    }\n\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n\n    setError(err as Error);\n  } finally {\n    setLoading(false);\n  }\n}\n","import { StreamPartType, parseStreamPart } from './stream-parts';\n\n// simple decoder signatures:\nfunction createChunkDecoder(): (chunk: Uint8Array | undefined) => string;\nfunction createChunkDecoder(\n  complex: false,\n): (chunk: Uint8Array | undefined) => string;\n// complex decoder signature:\nfunction createChunkDecoder(\n  complex: true,\n): (chunk: Uint8Array | undefined) => StreamPartType[];\n// combined signature for when the client calls this function with a boolean:\nfunction createChunkDecoder(\n  complex?: boolean,\n): (chunk: Uint8Array | undefined) => StreamPartType[] | string;\nfunction createChunkDecoder(complex?: boolean) {\n  const decoder = new TextDecoder();\n\n  if (!complex) {\n    return function (chunk: Uint8Array | undefined): string {\n      if (!chunk) return '';\n      return decoder.decode(chunk, { stream: true });\n    };\n  }\n\n  return function (chunk: Uint8Array | undefined) {\n    const decoded = decoder\n      .decode(chunk, { stream: true })\n      .split('\\n')\n      .filter(line => line !== ''); // splitting leaves an empty string at the end\n\n    return decoded.map(parseStreamPart).filter(Boolean);\n  };\n}\n\nexport { createChunkDecoder };\n","/**\n * Converts a data URL of type text/* to a text string.\n */\nexport function getTextFromDataUrl(dataUrl: string): string {\n  const [header, base64Content] = dataUrl.split(',');\n  const mimeType = header.split(';')[0].split(':')[1];\n\n  if (mimeType == null || base64Content == null) {\n    throw new Error('Invalid data URL format');\n  }\n\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n","/**\n * Performs a deep-equal comparison of two parsed JSON objects.\n *\n * @param {any} obj1 - The first object to compare.\n * @param {any} obj2 - The second object to compare.\n * @returns {boolean} - Returns true if the two objects are deeply equal, false otherwise.\n */\nexport function isDeepEqualData(obj1: any, obj2: any): boolean {\n  // Check for strict equality first\n  if (obj1 === obj2) return true;\n\n  // Check if either is null or undefined\n  if (obj1 == null || obj2 == null) return false;\n\n  // Check if both are objects\n  if (typeof obj1 !== 'object' && typeof obj2 !== 'object')\n    return obj1 === obj2;\n\n  // If they are not strictly equal, they both need to be Objects\n  if (obj1.constructor !== obj2.constructor) return false;\n\n  // Special handling for Date objects\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n\n  // Handle arrays: compare length and then perform a recursive deep comparison on each item\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length) return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i])) return false;\n    }\n    return true; // All array elements matched\n  }\n\n  // Compare the set of keys in each object\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length) return false;\n\n  // Check each key-value pair recursively\n  for (const key of keys1) {\n    if (!keys2.includes(key)) return false;\n    if (!isDeepEqualData(obj1[key], obj2[key])) return false;\n  }\n\n  return true; // All keys and values matched\n}\n","import {\n  ChatRequest,\n  FunctionCall,\n  JSONValue,\n  Message,\n  ToolCall,\n} from './types';\n\nexport async function processChatStream({\n  getStreamedResponse,\n  experimental_onFunctionCall,\n  experimental_onToolCall,\n  updateChatRequest,\n  getCurrentMessages,\n}: {\n  getStreamedResponse: () => Promise<\n    Message | { messages: Message[]; data: JSONValue[] }\n  >;\n  experimental_onFunctionCall?: (\n    chatMessages: Message[],\n    functionCall: FunctionCall,\n  ) => Promise<void | ChatRequest>;\n  experimental_onToolCall?: (\n    chatMessages: Message[],\n    toolCalls: ToolCall[],\n  ) => Promise<void | ChatRequest>;\n  updateChatRequest: (chatRequest: ChatRequest) => void;\n  getCurrentMessages: () => Message[];\n}) {\n  while (true) {\n    // TODO-STREAMDATA: This should be {  const { messages: streamedResponseMessages, data } =\n    // await getStreamedResponse(} once Stream Data is not experimental\n    const messagesAndDataOrJustMessage = await getStreamedResponse();\n\n    // Using experimental stream data\n    if ('messages' in messagesAndDataOrJustMessage) {\n      let hasFollowingResponse = false;\n\n      for (const message of messagesAndDataOrJustMessage.messages) {\n        // See if the message has a complete function call or tool call\n        if (\n          (message.function_call === undefined ||\n            typeof message.function_call === 'string') &&\n          (message.tool_calls === undefined ||\n            typeof message.tool_calls === 'string')\n        ) {\n          continue;\n        }\n\n        hasFollowingResponse = true;\n        // Try to handle function call\n        if (experimental_onFunctionCall) {\n          const functionCall = message.function_call;\n          // Make sure functionCall is an object\n          // If not, we got tool calls instead of function calls\n          if (typeof functionCall !== 'object') {\n            console.warn(\n              'experimental_onFunctionCall should not be defined when using tools',\n            );\n            continue;\n          }\n\n          // User handles the function call in their own functionCallHandler.\n          // The \"arguments\" key of the function call object will still be a string which will have to be parsed in the function handler.\n          // If the \"arguments\" JSON is malformed due to model error the user will have to handle that themselves.\n\n          const functionCallResponse: ChatRequest | void =\n            await experimental_onFunctionCall(\n              getCurrentMessages(),\n              functionCall,\n            );\n\n          // If the user does not return anything as a result of the function call, the loop will break.\n          if (functionCallResponse === undefined) {\n            hasFollowingResponse = false;\n            break;\n          }\n\n          // A function call response was returned.\n          // The updated chat with function call response will be sent to the API in the next iteration of the loop.\n          updateChatRequest(functionCallResponse);\n        }\n        // Try to handle tool call\n        if (experimental_onToolCall) {\n          const toolCalls = message.tool_calls;\n          // Make sure toolCalls is an array of objects\n          // If not, we got function calls instead of tool calls\n          if (\n            !Array.isArray(toolCalls) ||\n            toolCalls.some(toolCall => typeof toolCall !== 'object')\n          ) {\n            console.warn(\n              'experimental_onToolCall should not be defined when using tools',\n            );\n            continue;\n          }\n\n          // User handles the function call in their own functionCallHandler.\n          // The \"arguments\" key of the function call object will still be a string which will have to be parsed in the function handler.\n          // If the \"arguments\" JSON is malformed due to model error the user will have to handle that themselves.\n          const toolCallResponse: ChatRequest | void =\n            await experimental_onToolCall(getCurrentMessages(), toolCalls);\n\n          // If the user does not return anything as a result of the function call, the loop will break.\n          if (toolCallResponse === undefined) {\n            hasFollowingResponse = false;\n            break;\n          }\n\n          // A function call response was returned.\n          // The updated chat with function call response will be sent to the API in the next iteration of the loop.\n          updateChatRequest(toolCallResponse);\n        }\n      }\n      if (!hasFollowingResponse) {\n        break;\n      }\n    } else {\n      const streamedResponseMessage = messagesAndDataOrJustMessage;\n\n      // TODO-STREAMDATA: Remove this once Stream Data is not experimental\n      if (\n        (streamedResponseMessage.function_call === undefined ||\n          typeof streamedResponseMessage.function_call === 'string') &&\n        (streamedResponseMessage.tool_calls === undefined ||\n          typeof streamedResponseMessage.tool_calls === 'string')\n      ) {\n        break;\n      }\n\n      // If we get here and are expecting a function call, the message should have one, if not warn and continue\n      if (experimental_onFunctionCall) {\n        const functionCall = streamedResponseMessage.function_call;\n        if (!(typeof functionCall === 'object')) {\n          console.warn(\n            'experimental_onFunctionCall should not be defined when using tools',\n          );\n          continue;\n        }\n        const functionCallResponse: ChatRequest | void =\n          await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n\n        // If the user does not return anything as a result of the function call, the loop will break.\n        if (functionCallResponse === undefined) break;\n        // A function call response was returned.\n        // The updated chat with function call response will be sent to the API in the next iteration of the loop.\n        fixFunctionCallArguments(functionCallResponse);\n        updateChatRequest(functionCallResponse);\n      }\n      // If we get here and are expecting a tool call, the message should have one, if not warn and continue\n      if (experimental_onToolCall) {\n        const toolCalls = streamedResponseMessage.tool_calls;\n        if (!(typeof toolCalls === 'object')) {\n          console.warn(\n            'experimental_onToolCall should not be defined when using functions',\n          );\n          continue;\n        }\n        const toolCallResponse: ChatRequest | void =\n          await experimental_onToolCall(getCurrentMessages(), toolCalls);\n\n        // If the user does not return anything as a result of the function call, the loop will break.\n        if (toolCallResponse === undefined) break;\n        // A function call response was returned.\n        // The updated chat with function call response will be sent to the API in the next iteration of the loop.\n        fixFunctionCallArguments(toolCallResponse);\n        updateChatRequest(toolCallResponse);\n      }\n\n      // Make sure function call arguments are sent back to the API as a string\n      function fixFunctionCallArguments(response: ChatRequest) {\n        for (const message of response.messages) {\n          if (message.tool_calls !== undefined) {\n            for (const toolCall of message.tool_calls) {\n              if (typeof toolCall === 'object') {\n                if (\n                  toolCall.function.arguments &&\n                  typeof toolCall.function.arguments !== 'string'\n                ) {\n                  toolCall.function.arguments = JSON.stringify(\n                    toolCall.function.arguments,\n                  );\n                }\n              }\n            }\n          }\n          if (message.function_call !== undefined) {\n            if (typeof message.function_call === 'object') {\n              if (\n                message.function_call.arguments &&\n                typeof message.function_call.arguments !== 'string'\n              ) {\n                message.function_call.arguments = JSON.stringify(\n                  message.function_call.arguments,\n                );\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","import { Validator, validatorSymbol } from '@ai-sdk/provider-utils';\nimport { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport zodToJsonSchema from 'zod-to-json-schema';\n\n/**\n * Used to mark schemas so we can support both Zod and custom schemas.\n */\nconst schemaSymbol = Symbol.for('vercel.ai.schema');\n\nexport type Schema<OBJECT = unknown> = Validator<OBJECT> & {\n  /**\n   * Used to mark schemas so we can support both Zod and custom schemas.\n   */\n  [schemaSymbol]: true;\n\n  /**\n   * Schema type for inference.\n   */\n  _type: OBJECT;\n\n  /**\n   * The JSON Schema for the schema. It is passed to the providers.\n   */\n  readonly jsonSchema: JSONSchema7;\n};\n\n/**\n * Create a schema using a JSON Schema.\n *\n * @param jsonSchema The JSON Schema for the schema.\n * @param options.validate Optional. A validation function for the schema.\n */\nexport function jsonSchema<OBJECT = unknown>(\n  jsonSchema: JSONSchema7,\n  {\n    validate,\n  }: {\n    validate?: (\n      value: unknown,\n    ) => { success: true; value: OBJECT } | { success: false; error: Error };\n  } = {},\n): Schema<OBJECT> {\n  return {\n    [schemaSymbol]: true,\n    _type: undefined as OBJECT, // should never be used directly\n    [validatorSymbol]: true,\n    jsonSchema,\n    validate,\n  };\n}\n\nfunction isSchema(value: unknown): value is Schema {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    schemaSymbol in value &&\n    value[schemaSymbol] === true &&\n    'jsonSchema' in value &&\n    'validate' in value\n  );\n}\n\nexport function asSchema<OBJECT>(\n  schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>,\n): Schema<OBJECT> {\n  return isSchema(schema) ? schema : zodSchema(schema);\n}\n\nexport function zodSchema<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Schema<OBJECT> {\n  return jsonSchema(\n    // we assume that zodToJsonSchema will return a valid JSONSchema7:\n    zodToJsonSchema(zodSchema) as JSONSchema7,\n    {\n      validate: value => {\n        const result = zodSchema.safeParse(value);\n        return result.success\n          ? { success: true, value: result.data }\n          : { success: false, error: result.error };\n      },\n    },\n  );\n}\n"],"names":["ignored","streamParts","generateId","fetch","getOriginalFetch","fixFunctionCallArguments","jsonSchema","zodSchema"],"mappings":"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"}},
    {"offset": {"line": 3571, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3576, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@ai-sdk/react/src/use-assistant.ts","/turbopack/[project]/node_modules/@ai-sdk/react/src/use-chat.ts","/turbopack/[project]/node_modules/@ai-sdk/react/src/use-completion.ts","/turbopack/[project]/node_modules/@ai-sdk/react/src/use-object.ts"],"sourcesContent":["import { isAbortError } from '@ai-sdk/provider-utils';\nimport {\n  AssistantStatus,\n  CreateMessage,\n  Message,\n  UseAssistantOptions,\n  generateId,\n  readDataStream,\n} from '@ai-sdk/ui-utils';\nimport { useCallback, useRef, useState } from 'react';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport type UseAssistantHelpers = {\n  /**\n   * The current array of chat messages.\n   */\n  messages: Message[];\n\n  /**\n   * Update the message store with a new array of messages.\n   */\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;\n\n  /**\n   * The current thread ID.\n   */\n  threadId: string | undefined;\n\n  /**\n   * Set the current thread ID. Specifying a thread ID will switch to that thread, if it exists. If set to 'undefined', a new thread will be created. For both cases, `threadId` will be updated with the new value and `messages` will be cleared.\n   */\n  setThreadId: (threadId: string | undefined) => void;\n\n  /**\n   * The current value of the input field.\n   */\n  input: string;\n\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   * @param requestOptions Additional options to pass to the API call\n   */\n  append: (\n    message: Message | CreateMessage,\n    requestOptions?: {\n      data?: Record<string, string>;\n    },\n  ) => Promise<void>;\n\n  /**\nAbort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n\n  /**\n   * setState-powered method to update the input value.\n   */\n  setInput: React.Dispatch<React.SetStateAction<string>>;\n\n  /**\n   * Handler for the `onChange` event of the input field to control the input's value.\n   */\n  handleInputChange: (\n    event:\n      | React.ChangeEvent<HTMLInputElement>\n      | React.ChangeEvent<HTMLTextAreaElement>,\n  ) => void;\n\n  /**\n   * Form submission handler that automatically resets the input field and appends a user message.\n   */\n  submitMessage: (\n    event?: React.FormEvent<HTMLFormElement>,\n    requestOptions?: {\n      data?: Record<string, string>;\n    },\n  ) => Promise<void>;\n\n  /**\n   * The current status of the assistant. This can be used to show a loading indicator.\n   */\n  status: AssistantStatus;\n\n  /**\n   * The error thrown during the assistant message processing, if any.\n   */\n  error: undefined | Error;\n};\n\nexport function useAssistant({\n  api,\n  threadId: threadIdParam,\n  credentials,\n  headers,\n  body,\n  onError,\n  fetch,\n}: UseAssistantOptions): UseAssistantHelpers {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [input, setInput] = useState('');\n  const [currentThreadId, setCurrentThreadId] = useState<string | undefined>(\n    undefined,\n  );\n  const [status, setStatus] = useState<AssistantStatus>('awaiting_message');\n  const [error, setError] = useState<undefined | Error>(undefined);\n\n  const handleInputChange = (\n    event:\n      | React.ChangeEvent<HTMLInputElement>\n      | React.ChangeEvent<HTMLTextAreaElement>,\n  ) => {\n    setInput(event.target.value);\n  };\n\n  // Abort controller to cancel the current API call.\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const stop = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  const append = async (\n    message: Message | CreateMessage,\n    requestOptions?: {\n      data?: Record<string, string>;\n    },\n  ) => {\n    setStatus('in_progress');\n\n    setMessages(messages => [\n      ...messages,\n      {\n        ...message,\n        id: message.id ?? generateId(),\n      },\n    ]);\n\n    setInput('');\n\n    const abortController = new AbortController();\n\n    try {\n      abortControllerRef.current = abortController;\n\n      const actualFetch = fetch ?? getOriginalFetch();\n      const response = await actualFetch(api, {\n        method: 'POST',\n        credentials,\n        signal: abortController.signal,\n        headers: { 'Content-Type': 'application/json', ...headers },\n        body: JSON.stringify({\n          ...body,\n          // always use user-provided threadId when available:\n          threadId: threadIdParam ?? currentThreadId ?? null,\n          message: message.content,\n\n          // optional request data:\n          data: requestOptions?.data,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          (await response.text()) ?? 'Failed to fetch the assistant response.',\n        );\n      }\n\n      if (response.body == null) {\n        throw new Error('The response body is empty.');\n      }\n\n      for await (const { type, value } of readDataStream(\n        response.body.getReader(),\n      )) {\n        switch (type) {\n          case 'assistant_message': {\n            setMessages(messages => [\n              ...messages,\n              {\n                id: value.id,\n                role: value.role,\n                content: value.content[0].text.value,\n              },\n            ]);\n            break;\n          }\n\n          case 'text': {\n            // text delta - add to last message:\n            setMessages(messages => {\n              const lastMessage = messages[messages.length - 1];\n              return [\n                ...messages.slice(0, messages.length - 1),\n                {\n                  id: lastMessage.id,\n                  role: lastMessage.role,\n                  content: lastMessage.content + value,\n                },\n              ];\n            });\n\n            break;\n          }\n\n          case 'data_message': {\n            setMessages(messages => [\n              ...messages,\n              {\n                id: value.id ?? generateId(),\n                role: 'data',\n                content: '',\n                data: value.data,\n              },\n            ]);\n            break;\n          }\n\n          case 'assistant_control_data': {\n            setCurrentThreadId(value.threadId);\n\n            // set id of last message:\n            setMessages(messages => {\n              const lastMessage = messages[messages.length - 1];\n              lastMessage.id = value.messageId;\n              return [...messages.slice(0, messages.length - 1), lastMessage];\n            });\n\n            break;\n          }\n\n          case 'error': {\n            setError(new Error(value));\n            break;\n          }\n        }\n      }\n    } catch (error) {\n      // Ignore abort errors as they are expected when the user cancels the request:\n      if (isAbortError(error) && abortController.signal.aborted) {\n        abortControllerRef.current = null;\n        return;\n      }\n\n      if (onError && error instanceof Error) {\n        onError(error);\n      }\n\n      setError(error as Error);\n    } finally {\n      abortControllerRef.current = null;\n      setStatus('awaiting_message');\n    }\n  };\n\n  const submitMessage = async (\n    event?: React.FormEvent<HTMLFormElement>,\n    requestOptions?: {\n      data?: Record<string, string>;\n    },\n  ) => {\n    event?.preventDefault?.();\n\n    if (input === '') {\n      return;\n    }\n\n    append({ role: 'user', content: input }, requestOptions);\n  };\n\n  const setThreadId = (threadId: string | undefined) => {\n    setCurrentThreadId(threadId);\n    setMessages([]);\n  };\n\n  return {\n    append,\n    messages,\n    setMessages,\n    threadId: currentThreadId,\n    setThreadId,\n    input,\n    setInput,\n    handleInputChange,\n    submitMessage,\n    status,\n    error,\n    stop,\n  };\n}\n\n/**\n@deprecated Use `useAssistant` instead.\n */\nexport const experimental_useAssistant = useAssistant;\n","import { FetchFunction } from '@ai-sdk/provider-utils';\nimport type {\n  ChatRequest,\n  ChatRequestOptions,\n  Attachment,\n  CreateMessage,\n  IdGenerator,\n  JSONValue,\n  Message,\n  UseChatOptions,\n} from '@ai-sdk/ui-utils';\nimport {\n  callChatApi,\n  generateId as generateIdFunc,\n  processChatStream,\n} from '@ai-sdk/ui-utils';\nimport { useCallback, useEffect, useId, useRef, useState } from 'react';\nimport useSWR, { KeyedMutator } from 'swr';\n\nexport type { CreateMessage, Message, UseChatOptions };\n\nexport type UseChatHelpers = {\n  /** Current messages in the chat */\n  messages: Message[];\n  /** The error object of the API request */\n  error: undefined | Error;\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   * @param options Additional options to pass to the API call\n   */\n  append: (\n    message: Message | CreateMessage,\n    chatRequestOptions?: ChatRequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Reload the last AI chat response for the given chat history. If the last\n   * message isn't from the assistant, it will request the API to generate a\n   * new response.\n   */\n  reload: (\n    chatRequestOptions?: ChatRequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Abort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n  /**\n   * Update the `messages` state locally. This is useful when you want to\n   * edit the messages on the client, and then trigger the `reload` method\n   * manually to regenerate the AI response.\n   */\n  setMessages: (\n    messages: Message[] | ((messages: Message[]) => Message[]),\n  ) => void;\n  /** The current value of the input */\n  input: string;\n  /** setState-powered method to update the input value */\n  setInput: React.Dispatch<React.SetStateAction<string>>;\n  /** An input/textarea-ready onChange handler to control the value of the input */\n  handleInputChange: (\n    e:\n      | React.ChangeEvent<HTMLInputElement>\n      | React.ChangeEvent<HTMLTextAreaElement>,\n  ) => void;\n  /** Form submission handler to automatically reset input and append a user message */\n  handleSubmit: (\n    event?: { preventDefault?: () => void },\n    chatRequestOptions?: ChatRequestOptions,\n  ) => void;\n  metadata?: Object;\n  /** Whether the API request is in progress */\n  isLoading: boolean;\n  /** Additional data added on the server via StreamData */\n  data?: JSONValue[];\n};\n\nconst getStreamedResponse = async (\n  api: string,\n  chatRequest: ChatRequest,\n  mutate: KeyedMutator<Message[]>,\n  mutateStreamData: KeyedMutator<JSONValue[] | undefined>,\n  existingData: JSONValue[] | undefined,\n  extraMetadataRef: React.MutableRefObject<any>,\n  messagesRef: React.MutableRefObject<Message[]>,\n  abortControllerRef: React.MutableRefObject<AbortController | null>,\n  generateId: IdGenerator,\n  streamProtocol: UseChatOptions['streamProtocol'],\n  onFinish: UseChatOptions['onFinish'],\n  onResponse: ((response: Response) => void | Promise<void>) | undefined,\n  onToolCall: UseChatOptions['onToolCall'] | undefined,\n  sendExtraMessageFields: boolean | undefined,\n  experimental_prepareRequestBody:\n    | ((options: {\n        messages: Message[];\n        requestData?: JSONValue;\n        requestBody?: object;\n      }) => JSONValue)\n    | undefined,\n  fetch: FetchFunction | undefined,\n  keepLastMessageOnError: boolean,\n) => {\n  // Do an optimistic update to the chat state to show the updated messages immediately:\n  const previousMessages = messagesRef.current;\n  mutate(chatRequest.messages, false);\n\n  const constructedMessagesPayload = sendExtraMessageFields\n    ? chatRequest.messages\n    : chatRequest.messages.map(\n        ({\n          role,\n          content,\n          experimental_attachments,\n          name,\n          data,\n          annotations,\n          toolInvocations,\n          function_call,\n          tool_calls,\n          tool_call_id,\n        }) => ({\n          role,\n          content,\n          ...(experimental_attachments !== undefined && {\n            experimental_attachments,\n          }),\n          ...(name !== undefined && { name }),\n          ...(data !== undefined && { data }),\n          ...(annotations !== undefined && { annotations }),\n          ...(toolInvocations !== undefined && { toolInvocations }),\n          // outdated function/tool call handling (TODO deprecate):\n          tool_call_id,\n          ...(function_call !== undefined && { function_call }),\n          ...(tool_calls !== undefined && { tool_calls }),\n        }),\n      );\n\n  return await callChatApi({\n    api,\n    body: experimental_prepareRequestBody?.({\n      messages: chatRequest.messages,\n      requestData: chatRequest.data,\n      requestBody: chatRequest.body,\n    }) ?? {\n      messages: constructedMessagesPayload,\n      data: chatRequest.data,\n      ...extraMetadataRef.current.body,\n      ...chatRequest.body,\n      ...(chatRequest.functions !== undefined && {\n        functions: chatRequest.functions,\n      }),\n      ...(chatRequest.function_call !== undefined && {\n        function_call: chatRequest.function_call,\n      }),\n      ...(chatRequest.tools !== undefined && {\n        tools: chatRequest.tools,\n      }),\n      ...(chatRequest.tool_choice !== undefined && {\n        tool_choice: chatRequest.tool_choice,\n      }),\n    },\n    streamProtocol,\n    credentials: extraMetadataRef.current.credentials,\n    headers: {\n      ...extraMetadataRef.current.headers,\n      ...chatRequest.headers,\n    },\n    abortController: () => abortControllerRef.current,\n    restoreMessagesOnFailure() {\n      if (!keepLastMessageOnError) {\n        mutate(previousMessages, false);\n      }\n    },\n    onResponse,\n    onUpdate(merged, data) {\n      mutate([...chatRequest.messages, ...merged], false);\n      mutateStreamData([...(existingData || []), ...(data || [])], false);\n    },\n    onToolCall,\n    onFinish,\n    generateId,\n    fetch,\n  });\n};\n\nexport function useChat({\n  api = '/api/chat',\n  id,\n  initialMessages,\n  initialInput = '',\n  sendExtraMessageFields,\n  experimental_onFunctionCall,\n  experimental_onToolCall,\n  onToolCall,\n  experimental_prepareRequestBody,\n  experimental_maxAutomaticRoundtrips = 0,\n  maxAutomaticRoundtrips = experimental_maxAutomaticRoundtrips,\n  maxToolRoundtrips = maxAutomaticRoundtrips,\n  maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1,\n  streamMode,\n  streamProtocol,\n  onResponse,\n  onFinish,\n  onError,\n  credentials,\n  headers,\n  body,\n  generateId = generateIdFunc,\n  fetch,\n  keepLastMessageOnError = false,\n}: UseChatOptions & {\n  key?: string;\n\n  /**\n@deprecated Use `maxToolRoundtrips` instead.\n   */\n  experimental_maxAutomaticRoundtrips?: number;\n\n  /**\n@deprecated Use `maxToolRoundtrips` instead.\n   */\n  maxAutomaticRoundtrips?: number;\n\n  /**\n   * Experimental (React only). When a function is provided, it will be used\n   * to prepare the request body for the chat API. This can be useful for\n   * customizing the request body based on the messages and data in the chat.\n   *\n   * @param messages The current messages in the chat.\n   * @param requestData The data object passed in the chat request.\n   * @param requestBody The request body object passed in the chat request.\n   */\n  experimental_prepareRequestBody?: (options: {\n    messages: Message[];\n    requestData?: JSONValue;\n    requestBody?: object;\n  }) => JSONValue;\n\n  /**\nMaximum number of automatic roundtrips for tool calls.\n\nAn automatic tool call roundtrip is a call to the server with the\ntool call results when all tool calls in the last assistant\nmessage have results.\n\nA maximum number is required to prevent infinite loops in the\ncase of misconfigured tools.\n\nBy default, it's set to 0, which will disable the feature.\n\n@deprecated Use `maxSteps` instead (which is `maxToolRoundtrips` + 1).\n     */\n  maxToolRoundtrips?: number;\n\n  /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n */\n  maxSteps?: number;\n} = {}): UseChatHelpers & {\n  /**\n   * @deprecated Use `addToolResult` instead.\n   */\n  experimental_addToolResult: ({\n    toolCallId,\n    result,\n  }: {\n    toolCallId: string;\n    result: any;\n  }) => void;\n  addToolResult: ({\n    toolCallId,\n    result,\n  }: {\n    toolCallId: string;\n    result: any;\n  }) => void;\n} {\n  // streamMode is deprecated, use streamProtocol instead.\n  if (streamMode) {\n    streamProtocol ??= streamMode === 'text' ? 'text' : undefined;\n  }\n\n  // Generate a unique id for the chat if not provided.\n  const hookId = useId();\n  const idKey = id ?? hookId;\n  const chatKey = typeof api === 'string' ? [api, idKey] : idKey;\n\n  // Store a empty array as the initial messages\n  // (instead of using a default parameter value that gets re-created each time)\n  // to avoid re-renders:\n  const [initialMessagesFallback] = useState([]);\n\n  // Store the chat state in SWR, using the chatId as the key to share states.\n  const { data: messages, mutate } = useSWR<Message[]>(\n    [chatKey, 'messages'],\n    null,\n    { fallbackData: initialMessages ?? initialMessagesFallback },\n  );\n\n  // We store loading state in another hook to sync loading states across hook invocations\n  const { data: isLoading = false, mutate: mutateLoading } = useSWR<boolean>(\n    [chatKey, 'loading'],\n    null,\n  );\n\n  const { data: streamData, mutate: mutateStreamData } = useSWR<\n    JSONValue[] | undefined\n  >([chatKey, 'streamData'], null);\n\n  const { data: error = undefined, mutate: setError } = useSWR<\n    undefined | Error\n  >([chatKey, 'error'], null);\n\n  // Keep the latest messages in a ref.\n  const messagesRef = useRef<Message[]>(messages || []);\n  useEffect(() => {\n    messagesRef.current = messages || [];\n  }, [messages]);\n\n  // Abort controller to cancel the current API call.\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const extraMetadataRef = useRef({\n    credentials,\n    headers,\n    body,\n  });\n\n  useEffect(() => {\n    extraMetadataRef.current = {\n      credentials,\n      headers,\n      body,\n    };\n  }, [credentials, headers, body]);\n\n  const triggerRequest = useCallback(\n    async (chatRequest: ChatRequest) => {\n      const messageCount = messagesRef.current.length;\n\n      try {\n        mutateLoading(true);\n        setError(undefined);\n\n        const abortController = new AbortController();\n        abortControllerRef.current = abortController;\n\n        await processChatStream({\n          getStreamedResponse: () =>\n            getStreamedResponse(\n              api,\n              chatRequest,\n              mutate,\n              mutateStreamData,\n              streamData!,\n              extraMetadataRef,\n              messagesRef,\n              abortControllerRef,\n              generateId,\n              streamProtocol,\n              onFinish,\n              onResponse,\n              onToolCall,\n              sendExtraMessageFields,\n              experimental_prepareRequestBody,\n              fetch,\n              keepLastMessageOnError,\n            ),\n          experimental_onFunctionCall,\n          experimental_onToolCall,\n          updateChatRequest: chatRequestParam => {\n            chatRequest = chatRequestParam;\n          },\n          getCurrentMessages: () => messagesRef.current,\n        });\n\n        abortControllerRef.current = null;\n      } catch (err) {\n        // Ignore abort errors as they are expected.\n        if ((err as any).name === 'AbortError') {\n          abortControllerRef.current = null;\n          return null;\n        }\n\n        if (onError && err instanceof Error) {\n          onError(err);\n        }\n\n        setError(err as Error);\n      } finally {\n        mutateLoading(false);\n      }\n\n      // auto-submit when all tool calls in the last assistant message have results:\n      const messages = messagesRef.current;\n      const lastMessage = messages[messages.length - 1];\n      if (\n        // ensure we actually have new messages (to prevent infinite loops in case of errors):\n        messages.length > messageCount &&\n        // ensure there is a last message:\n        lastMessage != null &&\n        // check if the feature is enabled:\n        maxSteps > 1 &&\n        // check that next step is possible:\n        isAssistantMessageWithCompletedToolCalls(lastMessage) &&\n        // limit the number of automatic steps:\n        countTrailingAssistantMessages(messages) < maxSteps\n      ) {\n        await triggerRequest({ messages });\n      }\n    },\n    [\n      mutate,\n      mutateLoading,\n      api,\n      extraMetadataRef,\n      onResponse,\n      onFinish,\n      onError,\n      setError,\n      mutateStreamData,\n      streamData,\n      streamProtocol,\n      sendExtraMessageFields,\n      experimental_onFunctionCall,\n      experimental_onToolCall,\n      experimental_prepareRequestBody,\n      onToolCall,\n      maxSteps,\n      messagesRef,\n      abortControllerRef,\n      generateId,\n      fetch,\n      keepLastMessageOnError,\n    ],\n  );\n\n  const append = useCallback(\n    async (\n      message: Message | CreateMessage,\n      {\n        options,\n        functions,\n        function_call,\n        tools,\n        tool_choice,\n        data,\n        headers,\n        body,\n        experimental_attachments,\n      }: ChatRequestOptions = {},\n    ) => {\n      if (!message.id) {\n        message.id = generateId();\n      }\n\n      const attachmentsForRequest = await prepareAttachmentsForRequest(\n        experimental_attachments,\n      );\n\n      const requestOptions = {\n        headers: headers ?? options?.headers,\n        body: body ?? options?.body,\n      };\n\n      const messages = messagesRef.current.concat({\n        ...message,\n        id: message.id ?? generateId(),\n        createdAt: message.createdAt ?? new Date(),\n        experimental_attachments:\n          attachmentsForRequest.length > 0 ? attachmentsForRequest : undefined,\n      });\n\n      const chatRequest: ChatRequest = {\n        messages,\n        options: requestOptions,\n        headers: requestOptions.headers,\n        body: requestOptions.body,\n        data,\n        ...(functions !== undefined && { functions }),\n        ...(function_call !== undefined && { function_call }),\n        ...(tools !== undefined && { tools }),\n        ...(tool_choice !== undefined && { tool_choice }),\n      };\n\n      return triggerRequest(chatRequest);\n    },\n    [triggerRequest, generateId],\n  );\n\n  const reload = useCallback(\n    async ({\n      options,\n      functions,\n      function_call,\n      tools,\n      tool_choice,\n      data,\n      headers,\n      body,\n    }: ChatRequestOptions = {}) => {\n      if (messagesRef.current.length === 0) return null;\n\n      const requestOptions = {\n        headers: headers ?? options?.headers,\n        body: body ?? options?.body,\n      };\n\n      // Remove last assistant message and retry last user message.\n      const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n      if (lastMessage.role === 'assistant') {\n        const chatRequest: ChatRequest = {\n          messages: messagesRef.current.slice(0, -1),\n          options: requestOptions,\n          headers: requestOptions.headers,\n          body: requestOptions.body,\n          data,\n          ...(functions !== undefined && { functions }),\n          ...(function_call !== undefined && { function_call }),\n          ...(tools !== undefined && { tools }),\n          ...(tool_choice !== undefined && { tool_choice }),\n        };\n\n        return triggerRequest(chatRequest);\n      }\n\n      const chatRequest: ChatRequest = {\n        messages: messagesRef.current,\n        options: requestOptions,\n        headers: requestOptions.headers,\n        body: requestOptions.body,\n        data,\n        ...(functions !== undefined && { functions }),\n        ...(function_call !== undefined && { function_call }),\n        ...(tools !== undefined && { tools }),\n        ...(tool_choice !== undefined && { tool_choice }),\n      };\n\n      return triggerRequest(chatRequest);\n    },\n    [triggerRequest],\n  );\n\n  const stop = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  const setMessages = useCallback(\n    (messages: Message[] | ((messages: Message[]) => Message[])) => {\n      if (typeof messages === 'function') {\n        messages = messages(messagesRef.current);\n      }\n\n      mutate(messages, false);\n      messagesRef.current = messages;\n    },\n    [mutate],\n  );\n\n  // Input state and handlers.\n  const [input, setInput] = useState(initialInput);\n\n  const handleSubmit = useCallback(\n    async (\n      event?: { preventDefault?: () => void },\n      options: ChatRequestOptions = {},\n      metadata?: Object,\n    ) => {\n      event?.preventDefault?.();\n\n      if (!input && !options.allowEmptySubmit) return;\n\n      if (metadata) {\n        extraMetadataRef.current = {\n          ...extraMetadataRef.current,\n          ...metadata,\n        };\n      }\n\n      const attachmentsForRequest = await prepareAttachmentsForRequest(\n        options.experimental_attachments,\n      );\n\n      const requestOptions = {\n        headers: options.headers ?? options.options?.headers,\n        body: options.body ?? options.options?.body,\n      };\n\n      const messages =\n        !input && !attachmentsForRequest.length && options.allowEmptySubmit\n          ? messagesRef.current\n          : messagesRef.current.concat({\n              id: generateId(),\n              createdAt: new Date(),\n              role: 'user',\n              content: input,\n              experimental_attachments:\n                attachmentsForRequest.length > 0\n                  ? attachmentsForRequest\n                  : undefined,\n            });\n\n      const chatRequest: ChatRequest = {\n        messages,\n        options: requestOptions,\n        headers: requestOptions.headers,\n        body: requestOptions.body,\n        data: options.data,\n      };\n\n      triggerRequest(chatRequest);\n\n      setInput('');\n    },\n    [input, generateId, triggerRequest],\n  );\n\n  const handleInputChange = (e: any) => {\n    setInput(e.target.value);\n  };\n\n  const addToolResult = ({\n    toolCallId,\n    result,\n  }: {\n    toolCallId: string;\n    result: any;\n  }) => {\n    const updatedMessages = messagesRef.current.map((message, index, arr) =>\n      // update the tool calls in the last assistant message:\n      index === arr.length - 1 &&\n      message.role === 'assistant' &&\n      message.toolInvocations\n        ? {\n            ...message,\n            toolInvocations: message.toolInvocations.map(toolInvocation =>\n              toolInvocation.toolCallId === toolCallId\n                ? { ...toolInvocation, result }\n                : toolInvocation,\n            ),\n          }\n        : message,\n    );\n\n    mutate(updatedMessages, false);\n\n    // auto-submit when all tool calls in the last assistant message have results:\n    const lastMessage = updatedMessages[updatedMessages.length - 1];\n    if (isAssistantMessageWithCompletedToolCalls(lastMessage)) {\n      triggerRequest({ messages: updatedMessages });\n    }\n  };\n\n  return {\n    messages: messages || [],\n    error,\n    append,\n    reload,\n    stop,\n    setMessages,\n    input,\n    setInput,\n    handleInputChange,\n    handleSubmit,\n    isLoading,\n    data: streamData,\n    addToolResult,\n    experimental_addToolResult: addToolResult,\n  };\n}\n\n/**\nCheck if the message is an assistant message with completed tool calls.\nThe message must have at least one tool invocation and all tool invocations\nmust have a result.\n */\nfunction isAssistantMessageWithCompletedToolCalls(message: Message) {\n  return (\n    message.role === 'assistant' &&\n    message.toolInvocations &&\n    message.toolInvocations.length > 0 &&\n    message.toolInvocations.every(toolInvocation => 'result' in toolInvocation)\n  );\n}\n\n/**\nReturns the number of trailing assistant messages in the array.\n */\nfunction countTrailingAssistantMessages(messages: Message[]) {\n  let count = 0;\n  for (let i = messages.length - 1; i >= 0; i--) {\n    if (messages[i].role === 'assistant') {\n      count++;\n    } else {\n      break;\n    }\n  }\n  return count;\n}\n\nasync function prepareAttachmentsForRequest(\n  attachmentsFromOptions: FileList | Array<Attachment> | undefined,\n) {\n  if (attachmentsFromOptions == null) {\n    return [];\n  }\n\n  if (attachmentsFromOptions instanceof FileList) {\n    return Promise.all(\n      Array.from(attachmentsFromOptions).map(async attachment => {\n        const { name, type } = attachment;\n\n        const dataUrl = await new Promise<string>((resolve, reject) => {\n          const reader = new FileReader();\n          reader.onload = readerEvent => {\n            resolve(readerEvent.target?.result as string);\n          };\n          reader.onerror = error => reject(error);\n          reader.readAsDataURL(attachment);\n        });\n\n        return {\n          name,\n          contentType: type,\n          url: dataUrl,\n        };\n      }),\n    );\n  }\n\n  if (Array.isArray(attachmentsFromOptions)) {\n    return attachmentsFromOptions;\n  }\n\n  throw new Error('Invalid attachments type');\n}\n","import {\n  JSONValue,\n  RequestOptions,\n  UseCompletionOptions,\n  callCompletionApi,\n} from '@ai-sdk/ui-utils';\nimport { useCallback, useEffect, useId, useRef, useState } from 'react';\nimport useSWR from 'swr';\n\nexport type { UseCompletionOptions };\n\nexport type UseCompletionHelpers = {\n  /** The current completion result */\n  completion: string;\n  /**\n   * Send a new prompt to the API endpoint and update the completion state.\n   */\n  complete: (\n    prompt: string,\n    options?: RequestOptions,\n  ) => Promise<string | null | undefined>;\n  /** The error object of the API request */\n  error: undefined | Error;\n  /**\n   * Abort the current API request but keep the generated tokens.\n   */\n  stop: () => void;\n  /**\n   * Update the `completion` state locally.\n   */\n  setCompletion: (completion: string) => void;\n  /** The current value of the input */\n  input: string;\n  /** setState-powered method to update the input value */\n  setInput: React.Dispatch<React.SetStateAction<string>>;\n  /**\n   * An input/textarea-ready onChange handler to control the value of the input\n   * @example\n   * ```jsx\n   * <input onChange={handleInputChange} value={input} />\n   * ```\n   */\n  handleInputChange: (\n    event:\n      | React.ChangeEvent<HTMLInputElement>\n      | React.ChangeEvent<HTMLTextAreaElement>,\n  ) => void;\n\n  /**\n   * Form submission handler to automatically reset input and append a user message\n   * @example\n   * ```jsx\n   * <form onSubmit={handleSubmit}>\n   *  <input onChange={handleInputChange} value={input} />\n   * </form>\n   * ```\n   */\n  handleSubmit: (event?: { preventDefault?: () => void }) => void;\n\n  /** Whether the API request is in progress */\n  isLoading: boolean;\n  /** Additional data added on the server via StreamData */\n  data?: JSONValue[];\n};\n\nexport function useCompletion({\n  api = '/api/completion',\n  id,\n  initialCompletion = '',\n  initialInput = '',\n  credentials,\n  headers,\n  body,\n  streamMode,\n  streamProtocol,\n  fetch,\n  onResponse,\n  onFinish,\n  onError,\n}: UseCompletionOptions = {}): UseCompletionHelpers {\n  // streamMode is deprecated, use streamProtocol instead.\n  if (streamMode) {\n    streamProtocol ??= streamMode === 'text' ? 'text' : undefined;\n  }\n\n  // Generate an unique id for the completion if not provided.\n  const hookId = useId();\n  const completionId = id || hookId;\n\n  // Store the completion state in SWR, using the completionId as the key to share states.\n  const { data, mutate } = useSWR<string>([api, completionId], null, {\n    fallbackData: initialCompletion,\n  });\n\n  const { data: isLoading = false, mutate: mutateLoading } = useSWR<boolean>(\n    [completionId, 'loading'],\n    null,\n  );\n\n  const { data: streamData, mutate: mutateStreamData } = useSWR<\n    JSONValue[] | undefined\n  >([completionId, 'streamData'], null);\n\n  const [error, setError] = useState<undefined | Error>(undefined);\n  const completion = data!;\n\n  // Abort controller to cancel the current API call.\n  const [abortController, setAbortController] =\n    useState<AbortController | null>(null);\n\n  const extraMetadataRef = useRef({\n    credentials,\n    headers,\n    body,\n  });\n  useEffect(() => {\n    extraMetadataRef.current = {\n      credentials,\n      headers,\n      body,\n    };\n  }, [credentials, headers, body]);\n\n  const triggerRequest = useCallback(\n    async (prompt: string, options?: RequestOptions) =>\n      callCompletionApi({\n        api,\n        prompt,\n        credentials: extraMetadataRef.current.credentials,\n        headers: { ...extraMetadataRef.current.headers, ...options?.headers },\n        body: {\n          ...extraMetadataRef.current.body,\n          ...options?.body,\n        },\n        streamProtocol,\n        fetch,\n        setCompletion: completion => mutate(completion, false),\n        setLoading: mutateLoading,\n        setError,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        onData: data => {\n          mutateStreamData([...(streamData || []), ...(data || [])], false);\n        },\n      }),\n    [\n      mutate,\n      mutateLoading,\n      api,\n      extraMetadataRef,\n      setAbortController,\n      onResponse,\n      onFinish,\n      onError,\n      setError,\n      streamData,\n      streamProtocol,\n      fetch,\n      mutateStreamData,\n    ],\n  );\n\n  const stop = useCallback(() => {\n    if (abortController) {\n      abortController.abort();\n      setAbortController(null);\n    }\n  }, [abortController]);\n\n  const setCompletion = useCallback(\n    (completion: string) => {\n      mutate(completion, false);\n    },\n    [mutate],\n  );\n\n  const complete = useCallback<UseCompletionHelpers['complete']>(\n    async (prompt, options) => {\n      return triggerRequest(prompt, options);\n    },\n    [triggerRequest],\n  );\n\n  const [input, setInput] = useState(initialInput);\n\n  const handleSubmit = useCallback(\n    (event?: { preventDefault?: () => void }) => {\n      event?.preventDefault?.();\n      return input ? complete(input) : undefined;\n    },\n    [input, complete],\n  );\n\n  const handleInputChange = (e: any) => {\n    setInput(e.target.value);\n  };\n\n  return {\n    completion,\n    complete,\n    error,\n    setCompletion,\n    stop,\n    input,\n    setInput,\n    handleInputChange,\n    handleSubmit,\n    isLoading,\n    data: streamData,\n  };\n}\n","import {\n  FetchFunction,\n  isAbortError,\n  safeValidateTypes,\n} from '@ai-sdk/provider-utils';\nimport {\n  asSchema,\n  DeepPartial,\n  isDeepEqualData,\n  parsePartialJson,\n  Schema,\n} from '@ai-sdk/ui-utils';\nimport { useCallback, useId, useRef, useState } from 'react';\nimport useSWR from 'swr';\nimport z from 'zod';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport type Experimental_UseObjectOptions<RESULT> = {\n  /**\n   * The API endpoint. It should stream JSON that matches the schema as chunked text.\n   */\n  api: string;\n\n  /**\n   * A Zod schema that defines the shape of the complete object.\n   */\n  schema: z.Schema<RESULT, z.ZodTypeDef, any> | Schema<RESULT>;\n\n  /**\n   * An unique identifier. If not provided, a random one will be\n   * generated. When provided, the `useObject` hook with the same `id` will\n   * have shared states across components.\n   */\n  id?: string;\n\n  /**\n   * An optional value for the initial object.\n   */\n  initialValue?: DeepPartial<RESULT>;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: FetchFunction;\n\n  /**\nCallback that is called when the stream has finished.\n     */\n  onFinish?: (event: {\n    /**\nThe generated object (typed according to the schema).\nCan be undefined if the final object does not match the schema.\n   */\n    object: RESULT | undefined;\n\n    /**\nOptional error object. This is e.g. a TypeValidationError when the final object does not match the schema.\n */\n    error: Error | undefined;\n  }) => Promise<void> | void;\n\n  /**\n   * Callback function to be called when an error is encountered.\n   */\n  onError?: (error: Error) => void;\n\n  /**\n   * Additional HTTP headers to be included in the request.\n   */\n  headers?: Record<string, string> | Headers;\n};\n\nexport type Experimental_UseObjectHelpers<RESULT, INPUT> = {\n  /**\n   * @deprecated Use `submit` instead.\n   */\n  setInput: (input: INPUT) => void;\n\n  /**\n   * Calls the API with the provided input as JSON body.\n   */\n  submit: (input: INPUT) => void;\n\n  /**\n   * The current value for the generated object. Updated as the API streams JSON chunks.\n   */\n  object: DeepPartial<RESULT> | undefined;\n\n  /**\n   * The error object of the API request if any.\n   */\n  error: Error | undefined;\n\n  /**\n   * Flag that indicates whether an API request is in progress.\n   */\n  isLoading: boolean;\n\n  /**\n   * Abort the current request immediately, keep the current partial object if any.\n   */\n  stop: () => void;\n};\n\nfunction useObject<RESULT, INPUT = any>({\n  api,\n  id,\n  schema, // required, in the future we will use it for validation\n  initialValue,\n  fetch,\n  onError,\n  onFinish,\n  headers,\n}: Experimental_UseObjectOptions<RESULT>): Experimental_UseObjectHelpers<\n  RESULT,\n  INPUT\n> {\n  // Generate an unique id if not provided.\n  const hookId = useId();\n  const completionId = id ?? hookId;\n\n  // Store the completion state in SWR, using the completionId as the key to share states.\n  const { data, mutate } = useSWR<DeepPartial<RESULT>>(\n    [api, completionId],\n    null,\n    { fallbackData: initialValue },\n  );\n\n  const [error, setError] = useState<undefined | Error>(undefined);\n  const [isLoading, setIsLoading] = useState(false);\n\n  // Abort controller to cancel the current API call.\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const stop = useCallback(() => {\n    try {\n      abortControllerRef.current?.abort();\n    } catch (ignored) {\n    } finally {\n      setIsLoading(false);\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  const submit = async (input: INPUT) => {\n    try {\n      mutate(undefined); // reset the data\n      setIsLoading(true);\n      setError(undefined);\n\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n\n      const actualFetch = fetch ?? getOriginalFetch();\n      const response = await actualFetch(api, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...headers,\n        },\n        signal: abortController.signal,\n        body: JSON.stringify(input),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          (await response.text()) ?? 'Failed to fetch the response.',\n        );\n      }\n\n      if (response.body == null) {\n        throw new Error('The response body is empty.');\n      }\n\n      let accumulatedText = '';\n      let latestObject: DeepPartial<RESULT> | undefined = undefined;\n\n      await response.body.pipeThrough(new TextDecoderStream()).pipeTo(\n        new WritableStream<string>({\n          write(chunk) {\n            accumulatedText += chunk;\n\n            const { value } = parsePartialJson(accumulatedText);\n            const currentObject = value as DeepPartial<RESULT>;\n\n            if (!isDeepEqualData(latestObject, currentObject)) {\n              latestObject = currentObject;\n\n              mutate(currentObject);\n            }\n          },\n\n          close() {\n            setIsLoading(false);\n            abortControllerRef.current = null;\n\n            if (onFinish != null) {\n              const validationResult = safeValidateTypes({\n                value: latestObject,\n                schema: asSchema(schema),\n              });\n\n              onFinish(\n                validationResult.success\n                  ? { object: validationResult.value, error: undefined }\n                  : { object: undefined, error: validationResult.error },\n              );\n            }\n          },\n        }),\n      );\n    } catch (error) {\n      if (isAbortError(error)) {\n        return;\n      }\n\n      if (onError && error instanceof Error) {\n        onError(error);\n      }\n\n      setIsLoading(false);\n      setError(error instanceof Error ? error : new Error(String(error)));\n    }\n  };\n\n  return {\n    setInput: submit, // Deprecated\n    submit,\n    object: data,\n    error,\n    isLoading,\n    stop,\n  };\n}\n\nexport const experimental_useObject = useObject;\n"],"names":["fetch","messages","_a","error","generateId","useState","useRef","useCallback","headers","body","chatRequest","useId","useSWR","useEffect","completion","data","getOriginalFetch","isAbortError"],"mappings":"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"}},
    {"offset": {"line": 4422, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}